<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ°”æ³¡è‡ªå®šä¹‰å¯è§†åŒ–é¡µé¢</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥JSZipåº“ç”¨äºå¯¼å…¥å¯¼å‡ºåŠŸèƒ½ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- å¼•å…¥FileStorageManagerç›¸å…³è„šæœ¬ -->
    <script src="utils/fileStorageManager.js"></script>
    <script src="utils/imageStorageAPI.js"></script>
    <script src="utils/imageDisplayHelper.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- ä¸­æ–‡å­—ä½“CDNå¯¼å…¥ -->
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/dymh/dist/DouyinSansBold/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/hwmct/dist/æ±‡æ–‡æ˜æœä½“/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/ToneOZ-Pinyin-Kai/dist/ToneOZ-PinyinW-Kai-Simplified/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/hcqyt/dist/ChillRoundFBold/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/ysbzt/dist/å³„å±±ç¢‘ç¯†ä½“/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/yfxy/dist/YuFanXinYu-Medium/result.css' />
    <style>
        body { font-family: 'Inter', sans-serif; }
        input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:6px;background:#e2e8f0;border-radius:3px;outline:none;opacity:.7;transition:opacity .2s}
        input[type="range"]:hover{opacity:1}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:#4f46e5;cursor:pointer;border-radius:50%;border:2px solid #fff;box-shadow:0 0 5px rgba(0,0,0,.2)}
        input[type="color"]{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:40px;height:40px;background-color:transparent;border:none;cursor:pointer}
        input[type="color"]::-webkit-color-swatch{border-radius:50%;border:2px solid #e2e8f0}
        
        .sticker-wrapper {
            position: absolute;
            width: 120px;
            height: auto;
            cursor: grab;
            user-select: none;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .sticker-wrapper.selected {
            border: 2px dashed #4f46e5;
        }
        .sticker-wrapper.dragging {
            cursor: grabbing;
            z-index: 10000 !important;
        }
        .sticker-wrapper.inactive {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }
        .sticker-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain; /* æ”¹ä¸ºcontainä»¥æ›´å¥½åœ°æ”¯æŒSVG */
        }
        
        .resize-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background-color: #4f46e5;
            border: 2px solid white;
            border-radius: 4px;
            cursor: se-resize;
            z-index: 1001;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        #imageEditorCanvas.dropper-cursor { cursor: crosshair; }
        #stickerLibrary { position: absolute; bottom: 1rem; left: 1rem; z-index: 500; display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(255,255,255,0.8); padding: 0.5rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(5px); max-width: 280px; }
        .library-sticker { width: 60px; height: 60px; object-fit: contain; cursor: grab; transition: transform 0.2s; }
        .library-sticker:hover { transform: scale(1.1); }

        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            opacity: 1;
        }

        .bubble-type-btn {
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            outline: none;
        }
        .bubble-type-btn:hover {
            opacity: 0.8;
        }
        
        .sticker-container {
            position: relative;
        }
    </style>
    <!-- Analytics -->
    <script defer src="https://umami.whale-llt.top/script.js" data-website-id="00c95749-7c0d-4333-9ec1-2ad2701799a3"></script>
</head>
<body class="bg-slate-100 text-slate-800">
    <!-- Toast æç¤ºç»„ä»¶ -->
    <div id="toast" class="hidden fixed top-4 right-4 z-[9999] px-4 py-2 rounded-lg text-white font-medium shadow-lg transition-all duration-300"></div>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">äº¤äº’å¼æ°”æ³¡æ ·å¼è®¾è®¡å™¨</h1>
            <p class="text-slate-500 mt-2">å•å‡»é€‰ä¸­è´´å›¾å¯è°ƒæ•´å›¾å±‚ï¼ŒåŒå‡»å¯åˆ é™¤ã€‚</p>
        </header>

        <!-- ä¸»é¢˜ç®¡ç†å·¥å…·æ  -->
        <div class="bg-white rounded-2xl shadow-lg p-4 mb-6">
            <div class="flex flex-col md:flex-row gap-4 items-start md:items-center justify-between">
                <div class="flex-1 max-w-md">
                    <label for="themeSelect" class="text-sm font-medium text-slate-700 mb-1 block">å½“å‰ä¸»é¢˜</label>
                    <div class="flex gap-2">
                        <select id="themeSelect" class="flex-1 text-sm border border-slate-300 rounded-lg px-3 py-2 bg-white">
                            <option value="default">é»˜è®¤ä¸»é¢˜</option>
                        </select>
                        <button id="createNewThemeBtn" class="bg-green-500 text-white text-sm px-3 py-2 rounded hover:bg-green-600 whitespace-nowrap">æ–°å»º</button>
                        <button id="renameThemeBtn" class="bg-yellow-500 text-white text-sm px-3 py-2 rounded hover:bg-yellow-600 whitespace-nowrap">é‡å‘½å</button>
                        <button id="deleteThemeBtn" class="bg-red-500 text-white text-sm px-3 py-2 rounded hover:bg-red-600 whitespace-nowrap">åˆ é™¤</button>
                    </div>
                </div>
                
                <div class="flex gap-2">
                    <button id="exportThemeBtn" class="bg-blue-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors text-sm">ğŸ“¤ å¯¼å‡ºä¸»é¢˜</button>
                    <label for="importThemeFile" class="bg-amber-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-amber-600 transition-colors cursor-pointer text-sm">
                        ğŸ“¥ å¯¼å…¥ä¸»é¢˜
                        <input type="file" id="importThemeFile" accept=".zip" class="hidden">
                    </label>
                </div>
            </div>
        </div>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 bg-white rounded-2xl shadow-lg p-6 flex flex-col min-h-[400px] lg:min-h-[600px] overflow-hidden">
                <div class="flex-1 flex flex-col">
                    <!-- æ°”æ³¡ç±»å‹é€‰æ‹©æ§ä»¶ -->
                    <div class="mb-4 text-center">
                        <div class="inline-flex items-center bg-slate-200 rounded-full p-1">
                            <button id="bubbleTypeSelf" class="bubble-type-btn bg-white text-indigo-600 rounded-full px-4 py-2 text-sm font-semibold">æˆ‘çš„æ°”æ³¡</button>
                            <button id="bubbleTypeKare" class="bubble-type-btn text-slate-600 rounded-full px-4 py-2 text-sm font-semibold">å¯¹æ–¹æ°”æ³¡</button>
                        </div>
                    </div>
                    
                    <!-- åŒæ°”æ³¡é¢„è§ˆåŒºåŸŸ -->
                    <div id="previewContainer" class="relative flex-1 flex flex-col justify-center space-y-4 p-4">
                        <!-- æˆ‘çš„æ°”æ³¡ -->
                        <div class="flex justify-end">
                            <div id="previewBubbleSelf" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(135, 206, 250); border-radius: 12px;">
                                <span id="bubbleTextContentSelf" style="position: relative; z-index: 10; color: rgb(255, 255, 255);">
                                    è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯
                                </span>
                                <div id="stickerLibrarySelf" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <!-- å¯¹æ–¹æ°”æ³¡ -->
                        <div class="flex justify-start">
                            <div id="previewBubbleKare" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(255, 255, 255); border-radius: 12px;">
                                <span id="bubbleTextContentKare" style="position: relative; z-index: 10; color: rgb(51, 51, 51);">
                                    è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯
                                </span>
                                <div id="stickerLibraryKare" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <div id="stickerLibrary"></div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-2xl shadow-lg p-6 space-y-6 overflow-y-auto max-h-[calc(100vh-100px)]">

                <!-- é»˜è®¤ä¸»é¢˜é”å®šæç¤º -->
                <div id="defaultThemeNotice" class="hidden bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-3">
                    <div class="flex items-start">
                        <div class="flex-shrink-0">
                            <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <div class="ml-3">
                            <h3 class="text-sm font-medium text-yellow-800">ä¸»é¢˜è¢«é”å®š</h3>
                            <p class="mt-1 text-sm text-yellow-700">é»˜è®¤ä¸»é¢˜ä¸å¯ä¿®æ”¹ã€‚ç‚¹å‡»"æ–°å»º"ä»¥åˆ›å»ºå¯ä¿®æ”¹çš„ä¸»é¢˜ã€‚</p>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">è´´çº¸è´´å›¾</h3>
                    <button id="manageStickersBtn" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">ç®¡ç†è´´å›¾åº“</button>
                </div>
                <div id="layerControlPanel">
                    <h3 class="font-semibold text-lg mb-3">å›¾å±‚é¡ºåº</h3>
                    <div class="flex gap-2">
                        <button id="sendToBackBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>ç½®äºåº•å±‚</button>
                        <button id="bringToFrontBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>ç½®äºé¡¶å±‚</button>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">æ°”æ³¡åŸºç¡€æ ·å¼</h3>
                    <div class="space-y-4">
                        <div><label for="borderWidth" class="flex justify-between text-sm font-medium text-slate-700">è¾¹æ¡†å®½åº¦ <span id="borderWidthValue">1px</span></label><input type="range" id="borderWidth" min="0" max="50" value="1" class="mt-1"></div>
                        <div><label for="borderColor" class="flex justify-between items-center text-sm font-medium text-slate-700">è¾¹æ¡†é¢œè‰² <input type="color" id="borderColor" value="#4f46e5"></label></div>
                        <div><label for="textColor" class="flex justify-between items-center text-sm font-medium text-slate-700">æ–‡æœ¬é¢œè‰² <input type="color" id="textColor" value="#333333"></label></div>
                        <div>
                            <label for="fontFamily" class="text-sm font-medium text-slate-700">å­—ä½“é€‰æ‹©</label>
                            <select id="fontFamily" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                <option value="Inter">é»˜è®¤å­—ä½“ (Inter)</option>
                                <option value="Source Han Serif CN VF">æ€æºå®‹ä½“</option>
                                <option value="LXGW WenKai">éœé¹œæ–‡æ¥·</option>
                                <option value="Douyin Sans">æŠ–éŸ³ç¾å¥½ä½“</option>
                                <option value="Huiwen-mincho">æ±‡æ–‡æ˜æœä½“</option>
                                <option value="ToneOZ-PinyinW-Kai-Simplified">æ‹¼éŸ³é¼æ¥·</option>
                                <option value="å¯’è‰å…¨åœ†ä½“ Bold">å¯’è‰å…¨åœ†ä½“</option>
                                <option value="å³„å±±ç¢‘ç¯†ä½“">å³„å±±ç¢‘ç¯†ä½“</option>
                                <option value="YuFanXinYu-Medium">ä½™ç¹æ–°è¯­</option>
                            </select>
                        </div>
                        <div><label for="borderRadius" class="flex justify-between text-sm font-medium text-slate-700">åœ†è§’åŠå¾„ <span id="borderRadiusValue">12px</span></label><input type="range" id="borderRadius" min="0" max="100" value="12" class="mt-1"></div>
                        <div class="flex items-center justify-between"><span class="text-sm font-medium text-slate-700">èƒŒæ™¯ç±»å‹</span><div class="flex items-center bg-slate-200 rounded-full p-1"><button id="bgTypeSolid" class="bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold">çº¯è‰²</button><button id="bgTypeGradient" class="bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold">æ¸å˜</button></div></div>
                        <div id="solidBgControls">
                             <div class="flex items-center justify-between"><label for="bgColor" class="text-sm font-medium text-slate-700">èƒŒæ™¯é¢œè‰²</label><input type="color" id="bgColor" value="#ffffff"></div>
                            <div><label for="bgOpacity" class="flex justify-between text-sm font-medium text-slate-700">é€æ˜åº¦ <span id="bgOpacityValue">100%</span></label><input type="range" id="bgOpacity" min="0" max="1" step="0.01" value="1" class="mt-1"></div>
                        </div>
                        <div id="gradientBgControls" class="hidden space-y-4">
                            <div class="flex items-center justify-between"><label for="gradientColor1" class="text-sm font-medium text-slate-700">é¢œè‰² 1</label><input type="color" id="gradientColor1" value="#a5b4fc"></div>
                            <div class="flex items-center justify-between"><label for="gradientColor2" class="text-sm font-medium text-slate-700">é¢œè‰² 2</label><input type="color" id="gradientColor2" value="#e0e7ff"></div>
                            <div><label for="gradientAngle" class="flex justify-between text-sm font-medium text-slate-700">æ¸å˜è§’åº¦ <span id="gradientAngleValue">145deg</span></label><input type="range" id="gradientAngle" min="0" max="360" value="145" class="mt-1"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">é¢„è§ˆå†…å®¹</h3>
                    <div class="space-y-4">
                        <div><label for="bubbleText" class="text-sm font-medium text-slate-700">é¢„è§ˆæ–‡æœ¬</label><textarea id="bubbleText" rows="3" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">è¿™é‡Œæ˜¯ä½ çš„æ°”æ³¡é¢„è§ˆåŒºåŸŸã€‚ç‚¹å‡»"ç®¡ç†è´´å›¾åº“"å¼€å§‹åˆ›ä½œï¼</textarea></div>
                        
                        <div class="flex gap-2" id="actionButtons">
                            <button id="saveOnlyBtn" class="flex-1 bg-blue-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors">ä¿å­˜</button>
                            <button id="generateCodeBtn" class="flex-1 bg-emerald-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors">ä¿å­˜å¹¶åº”ç”¨</button>
                        </div>
                      </div>
                </div>
            </div>
        </main>
    </div>

    <!-- è´´å›¾ç®¡ç†å™¨ Modal -->
    <div id="imageProcessorModal" class="fixed inset-0 bg-black bg-opacity-50 z-[1000] hidden flex items-center justify-center p-4">
        <div class="w-full h-full max-w-6xl max-h-[90vh] bg-white rounded-2xl shadow-2xl flex flex-col md:flex-row">
            <div class="w-full md:w-1/3 flex flex-col border-r border-slate-200">
                <div class="p-4 border-b border-slate-200">
                    <h3 class="font-bold text-xl">è´´å›¾åº“</h3>
                    <p class="text-sm text-slate-500">åœ¨è¿™é‡Œç®¡ç†å’Œç¼–è¾‘ä½ çš„è´´å›¾ã€‚</p>
                </div>
                <div id="stickerGallery" class="flex-1 p-4 overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-4">
                </div>
                <div class="p-4 border-t border-slate-200 space-y-2">
                    <label for="galleryStickerUpload" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">ä¸Šä¼ æ–°è´´å›¾</label>
                    <input type="file" id="galleryStickerUpload" accept="image/*" multiple class="hidden">
                    
                    <button id="toggleSvgInputBtn" class="w-full bg-purple-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-purple-700 transition-colors">è¾“å…¥SVGä»£ç </button>
                    
                    <div id="svgInputSection" class="hidden space-y-2 bg-slate-50 p-3 rounded-lg border">
                        <label for="svgCodeInput" class="text-sm font-medium text-slate-700">SVGä»£ç </label>
                        <textarea id="svgCodeInput" rows="4" class="w-full p-2 border border-slate-300 rounded text-xs font-mono" placeholder='è¾“å…¥SVGä»£ç ï¼Œä¾‹å¦‚ï¼š
&lt;svg width="100" height="100" viewBox="0 0 100 100"&gt;
  &lt;circle cx="50" cy="50" r="40" fill="blue" /&gt;
&lt;/svg&gt;'></textarea>
                        <div class="flex gap-2">
                            <button id="addSvgBtn" class="flex-1 bg-green-600 text-white text-sm font-medium py-1.5 px-3 rounded hover:bg-green-700 transition-colors">æ·»åŠ SVG</button>
                            <button id="clearSvgBtn" class="flex-1 bg-slate-500 text-white text-sm font-medium py-1.5 px-3 rounded hover:bg-slate-600 transition-colors">æ¸…ç©º</button>
                        </div>
                    </div>
                    
                    <p class="text-xs text-slate-500 mt-2 text-center">æç¤ºï¼šç§»é™¤èƒŒæ™¯åŠŸèƒ½ä¸æ”¯æŒGIFåŠ¨å›¾ã€‚è¯·å…ˆä½¿ç”¨å¤–éƒ¨å·¥å…·å¤„ç†GIFï¼Œå†ä¸Šä¼ ã€‚</p>
                    <button id="closeProcessorBtn" class="w-full bg-slate-600 text-white font-medium py-2 rounded-lg hover:bg-slate-700 mt-2">å®Œæˆå¹¶å…³é—­</button>
                </div>
            </div>
            <div class="w-full md:w-2/3 flex flex-col">
                <div id="imageEditor" class="flex-1 flex items-center justify-center bg-slate-100 p-4 relative">
                    <canvas id="imageEditorCanvas" class="max-w-full max-h-full shadow-lg"></canvas>
                    <div id="editorPlaceholder" class="text-slate-500">ä»å·¦ä¾§é€‰æ‹©ä¸€å¼ å›¾ç‰‡è¿›è¡Œç¼–è¾‘</div>
                </div>
                <div id="editorControls" class="p-4 border-t border-slate-200 bg-white space-y-4 hidden">
                    <button id="removeBgBtn" class="w-full bg-indigo-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-indigo-600">ğŸ’§ ç§»é™¤èƒŒæ™¯</button>
                    <div>
                        <label for="tolerance" class="flex justify-between text-sm font-medium text-slate-700">å®¹å·® <span id="toleranceValue">20</span></label>
                        <input type="range" id="tolerance" min="0" max="150" value="20" class="mt-1">
                    </div>
                    <div class="flex gap-2">
                        <button id="saveChangesBtn" class="w-full bg-emerald-500 text-white font-medium py-2 rounded-lg hover:bg-emerald-600">ä¿å­˜æ›´æ”¹</button>
                        <button id="resetStickerBtn" class="w-full bg-gray-500 text-white font-medium py-2 rounded-lg hover:bg-gray-600">é‡ç½®å›¾ç‰‡</button>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const previewContainer = document.getElementById('previewContainer');
            const previewBubbleSelf = document.getElementById('previewBubbleSelf');
            const previewBubbleKare = document.getElementById('previewBubbleKare');
            const bubbleTextContentSelf = document.getElementById('bubbleTextContentSelf');
            const bubbleTextContentKare = document.getElementById('bubbleTextContentKare');
            const stickerLibraryContainer = document.getElementById('stickerLibrary');
            const imageProcessorModal = document.getElementById('imageProcessorModal');
            const stickerGallery = document.getElementById('stickerGallery');
            const imageEditorCanvas = document.getElementById('imageEditorCanvas');
            const editorControls = document.getElementById('editorControls');
            const editorPlaceholder = document.getElementById('editorPlaceholder');
            const ctx = imageEditorCanvas.getContext('2d');
            
            const controls = {
                manageStickersBtn: document.getElementById('manageStickersBtn'),
                closeProcessorBtn: document.getElementById('closeProcessorBtn'),
                galleryStickerUpload: document.getElementById('galleryStickerUpload'),
                toggleSvgInputBtn: document.getElementById('toggleSvgInputBtn'),
                svgInputSection: document.getElementById('svgInputSection'),
                svgCodeInput: document.getElementById('svgCodeInput'),
                addSvgBtn: document.getElementById('addSvgBtn'),
                clearSvgBtn: document.getElementById('clearSvgBtn'),
                removeBgBtn: document.getElementById('removeBgBtn'),
                tolerance: document.getElementById('tolerance'),
                toleranceValue: document.getElementById('toleranceValue'),
                saveChangesBtn: document.getElementById('saveChangesBtn'),
                resetStickerBtn: document.getElementById('resetStickerBtn'),
                sendToBackBtn: document.getElementById('sendToBackBtn'),
                bringToFrontBtn: document.getElementById('bringToFrontBtn'),
                borderWidth: document.getElementById('borderWidth'),
                borderWidthValue: document.getElementById('borderWidthValue'),
                borderColor: document.getElementById('borderColor'),
                textColor: document.getElementById('textColor'),
                fontFamily: document.getElementById('fontFamily'),
                borderRadius: document.getElementById('borderRadius'),
                borderRadiusValue: document.getElementById('borderRadiusValue'),
                bgTypeSolid: document.getElementById('bgTypeSolid'),
                bgTypeGradient: document.getElementById('bgTypeGradient'),
                solidBgControls: document.getElementById('solidBgControls'),
                gradientBgControls: document.getElementById('gradientBgControls'),
                bgColor: document.getElementById('bgColor'),
                bgOpacity: document.getElementById('bgOpacity'),
                bgOpacityValue: document.getElementById('bgOpacityValue'),
                gradientColor1: document.getElementById('gradientColor1'),
                gradientColor2: document.getElementById('gradientColor2'),
                gradientAngle: document.getElementById('gradientAngle'),
                gradientAngleValue: document.getElementById('gradientAngleValue'),
                bubbleText: document.getElementById('bubbleText'),
                defaultThemeNotice: document.getElementById('defaultThemeNotice'),
                actionButtons: document.getElementById('actionButtons'),
                saveOnlyBtn: document.getElementById('saveOnlyBtn'),
                generateCodeBtn: document.getElementById('generateCodeBtn'),
                exportThemeBtn: document.getElementById('exportThemeBtn'),
                importThemeFile: document.getElementById('importThemeFile'),
                themeSelect: document.getElementById('themeSelect'),
                createNewThemeBtn: document.getElementById('createNewThemeBtn'),
                renameThemeBtn: document.getElementById('renameThemeBtn'),
                deleteThemeBtn: document.getElementById('deleteThemeBtn'),
                bubbleTypeSelf: document.getElementById('bubbleTypeSelf'),
                bubbleTypeKare: document.getElementById('bubbleTypeKare'),
            };

            const DB_NAME = 'WhaleLLTDB';
            const DB_VERSION = 12;
            let db = null;
            let fileStorageManager = null;
            let stickerLibrary = [];
            let currentEditingStickerId = null;
            let targetColor = null;
            let currentBgType = 'solid';
            let selectedStickerWrapper = null;
            let zIndexCounter = 11;
            let currentBubbleType = 'self'; // 'self' æˆ– 'kare'


            async function initStorageSystem() {
                try {
                    // ç›´æ¥ä½¿ç”¨ä¸»åº”ç”¨çš„ç°æœ‰æ•°æ®åº“è¿æ¥
                    if (window.parent && window.parent.db && window.parent.isIndexedDBReady) {
                        db = window.parent.db;
                        console.log('ä½¿ç”¨ä¸»åº”ç”¨çš„ç°æœ‰æ•°æ®åº“è¿æ¥ï¼Œç‰ˆæœ¬:', db.version);
                    } else {
                        // å¦‚æœæ²¡æœ‰çˆ¶çª—å£è¿æ¥ï¼Œåˆ›å»ºç‹¬ç«‹è¿æ¥
                        fileStorageManager = new FileStorageManager();
                        await fileStorageManager.init();
                        db = fileStorageManager.db;
                        console.log('åˆ›å»ºç‹¬ç«‹æ•°æ®åº“è¿æ¥æˆåŠŸ');
                    }
                    
                    // å¦‚æœè¿˜æ²¡æœ‰fileStorageManagerï¼Œåˆ›å»ºä¸€ä¸ªå¹¶ä½¿ç”¨ç°æœ‰è¿æ¥
                    if (!fileStorageManager) {
                        fileStorageManager = new FileStorageManager();
                        fileStorageManager.db = db;
                        console.log('FileStorageManageråˆå§‹åŒ–æˆåŠŸ');
                    }
                    
                    return true;
                } catch (error) {
                    console.error('å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
                    showToast('å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨å†…å­˜å­˜å‚¨');
                    return false;
                }
            }

            async function saveStickerLibraryToStorage() {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡ä¿å­˜');
                        return;
                    }
                    
                    // ä½¿ç”¨ç°æœ‰æ•°æ®åº“çš„ themeConfig è¡¨ä¿å­˜è´´å›¾åº“
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // ä¿å­˜æ•´ä¸ªè´´å›¾åº“ä½œä¸ºä¸€ä¸ªä¸»é¢˜é…ç½®
                    const libraryData = {
                        type: 'bubbleStickers',
                        data: stickerLibrary,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(libraryData);
                    
                    transaction.oncomplete = () => {
                        console.log('è´´å›¾åº“ä¿å­˜åˆ° themeConfig æˆåŠŸ');
                    };
                    
                    transaction.onerror = () => {
                        console.error('è´´å›¾åº“ä¿å­˜å¤±è´¥:', transaction.error);
                        showToast('ä¿å­˜å¤±è´¥ï¼š' + transaction.error.message);
                    };
                } catch (e) {
                    console.error("æ— æ³•ä¿å­˜è´´å›¾åº“:", e);
                    showToast("é”™è¯¯ï¼šæ— æ³•ä¿å­˜è´´å›¾åº“ã€‚");
                }
            }

            async function loadStickerLibraryFromStorage() {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œä½¿ç”¨ç©ºè´´å›¾åº“');
                        stickerLibrary = [];
                        return;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get('bubbleStickers');
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result && result.data) {
                                stickerLibrary = result.data;
                                console.log('è´´å›¾åº“ä» themeConfig åŠ è½½æˆåŠŸï¼Œå…±', stickerLibrary.length, 'ä¸ªè´´å›¾');
                            } else {
                                stickerLibrary = [];
                                console.log('æœªæ‰¾åˆ°å·²ä¿å­˜çš„è´´å›¾åº“ï¼Œä½¿ç”¨ç©ºåº“');
                            }
                            resolve();
                        };
                        
                        request.onerror = () => {
                            console.error('åŠ è½½è´´å›¾åº“å¤±è´¥:', request.error);
                            stickerLibrary = [];
                            resolve(); // å³ä½¿å¤±è´¥ä¹Ÿè¦ç»§ç»­
                        };
                    });
                } catch (e) {
                    console.error("æ— æ³•åŠ è½½è´´å›¾åº“:", e);
                    stickerLibrary = [];
                }
            }

            function updateBubbleStyle() {
                const borderWidth = controls.borderWidth.value;
                const borderRadius = controls.borderRadius.value;
                
                // è·å–å½“å‰ç¼–è¾‘çš„æ°”æ³¡å…ƒç´ 
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                
                console.log(`updateBubbleStyle: currentBgType=${currentBgType}, æ¸å˜è‰²1=${controls.gradientColor1.value}, æ¸å˜è‰²2=${controls.gradientColor2.value}`);
                
                // æ¸…ç†ä¹‹å‰çš„èƒŒæ™¯æ ·å¼ï¼Œé¿å…æ ·å¼å†²çª
                currentBubble.style.background = '';
                currentBubble.style.backgroundColor = '';
                
                currentBubble.style.borderWidth = `${borderWidth}px`;
                currentBubble.style.borderColor = controls.borderColor.value;
                currentBubble.style.borderRadius = `${borderRadius}px`;
                
                // æ›´æ–°æ–‡æœ¬é¢œè‰²
                currentTextContent.style.color = controls.textColor.value;
                
                // æ›´æ–°å­—ä½“
                currentTextContent.style.fontFamily = controls.fontFamily.value;

                if (currentBgType === 'solid') {
                    const color = controls.bgColor.value;
                    const opacity = controls.bgOpacity.value;
                    const r = parseInt(color.slice(1, 3), 16), g = parseInt(color.slice(3, 5), 16), b = parseInt(color.slice(5, 7), 16);
                    currentBubble.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                } else {
                    const color1 = controls.gradientColor1.value, color2 = controls.gradientColor2.value, angle = controls.gradientAngle.value;
                    currentBubble.style.background = `linear-gradient(${angle}deg, ${color1}, ${color2})`;
                }
                controls.borderWidthValue.textContent = `${borderWidth}px`;
                controls.borderRadiusValue.textContent = `${borderRadius}px`;
                controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
            }

            // è·å–å½“å‰æ°”æ³¡ç±»å‹
            function getCurrentBubbleType() {
                return currentBubbleType || 'self';
            }

            // æ›´æ–°æ‰€æœ‰è´´çº¸çš„äº¤äº’çŠ¶æ€
            function updateStickersInteractionState() {
                // æ›´æ–°è‡ªå·±æ°”æ³¡ä¸­çš„è´´çº¸çŠ¶æ€
                previewBubbleSelf.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'self') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });

                // æ›´æ–°å¯¹æ–¹æ°”æ³¡ä¸­çš„è´´çº¸çŠ¶æ€
                previewBubbleKare.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'kare') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });
            }

            // åˆ‡æ¢æ°”æ³¡ç±»å‹
            async function switchBubbleType(type) {
                const oldType = currentBubbleType;
                
                // ä¿å­˜å½“å‰UIçŠ¶æ€åˆ°ç¼“å­˜ï¼ˆåœ¨åˆ‡æ¢ä¹‹å‰ï¼‰
                // ä½†å¦‚æœå½“å‰æ˜¯é»˜è®¤ä¸»é¢˜ï¼Œä¸ä¿å­˜çŠ¶æ€åˆ°ç¼“å­˜ï¼Œå› ä¸ºé»˜è®¤ä¸»é¢˜æ˜¯åªè¯»çš„
                if (oldType && currentThemeName !== 'default') {
                    uiStateCache[oldType] = captureCurrentUIState();
                    console.log(`å·²ä¿å­˜${oldType}çš„UIçŠ¶æ€åˆ°ç¼“å­˜`);
                } else if (oldType && currentThemeName === 'default') {
                    console.log(`è·³è¿‡ä¿å­˜é»˜è®¤ä¸»é¢˜çš„UIçŠ¶æ€åˆ°ç¼“å­˜ï¼ˆé»˜è®¤ä¸»é¢˜æ˜¯åªè¯»çš„ï¼‰`);
                }
                
                currentBubbleType = type;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                if (type === 'self') {
                    controls.bubbleTypeSelf.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.remove('text-slate-600');
                    controls.bubbleTypeKare.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeKare.classList.add('text-slate-600');
                } else {
                    controls.bubbleTypeKare.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeKare.classList.remove('text-slate-600');
                    controls.bubbleTypeSelf.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.add('text-slate-600');
                }
                
                // æ ¹æ®å½“å‰ä¸»é¢˜åŠ è½½UIçŠ¶æ€
                if (currentThemeName === 'default') {
                    // é»˜è®¤ä¸»é¢˜ï¼šå§‹ç»ˆä½¿ç”¨å›ºå®šçš„é»˜è®¤é…ç½®
                    const defaultConfig = DEFAULT_THEME_CONFIG[type];
                    console.log(`åŠ è½½é»˜è®¤ä¸»é¢˜çš„${type}é…ç½®`);
                    await applyConfigToUI(type, defaultConfig);
                } else if (uiStateCache[type]) {
                    console.log(`ä»ç¼“å­˜åŠ è½½${type}çš„UIçŠ¶æ€`);
                    applyUIState(uiStateCache[type]);
                } else {
                    console.log(`ç¼“å­˜ä¸­æ²¡æœ‰${type}çš„çŠ¶æ€ï¼Œä»æ•°æ®åº“åŠ è½½`);
                    await loadBubbleTypeSettings(type);
                    // åŠ è½½åç«‹å³ç¼“å­˜
                    uiStateCache[type] = captureCurrentUIState();
                }
                
                // æ›´æ–°é¢„è§ˆæ ·å¼
                updateBubbleStyle();
                
                // æ›´æ–°è´´çº¸äº¤äº’çŠ¶æ€
                updateStickersInteractionState();
                
                showToast(`å·²åˆ‡æ¢åˆ°${type === 'self' ? 'æˆ‘çš„æ°”æ³¡' : 'å¯¹æ–¹æ°”æ³¡'}ç¼–è¾‘æ¨¡å¼`);
            }

            // åŠ è½½æŒ‡å®šæ°”æ³¡ç±»å‹çš„è®¾ç½®
            async function loadBubbleTypeSettings(type) {
                const targetBubble = type === 'self' ? previewBubbleSelf : previewBubbleKare;
                const targetTextContent = type === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                
                // é¦–å…ˆå°è¯•ä»ä¿å­˜çš„é…ç½®ä¸­åŠ è½½
                const styleKey = type === 'self' ? 'bubbleStyleSelf' : 'bubbleStyle';
                const savedConfig = await loadBubbleStyleConfig(styleKey);
                
                if (savedConfig) {
                    // å¦‚æœæœ‰ä¿å­˜çš„é…ç½®ï¼Œåº”ç”¨åˆ°æ§ä»¶
                    console.log(`åŠ è½½${type === 'self' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}æ°”æ³¡ä¿å­˜é…ç½®`);
                    
                    // åº”ç”¨åŸºç¡€æ ·å¼åˆ°æ§ä»¶
                    controls.borderWidth.value = savedConfig.borderWidth || 1;
                    controls.borderColor.value = extractRgbColor(savedConfig.borderColor) || '#4f46e5';
                    controls.borderRadius.value = savedConfig.borderRadius || 12;
                    controls.textColor.value = extractRgbColor(savedConfig.textColor) || '#333333';
                    controls.fontFamily.value = savedConfig.fontFamily || 'Inter';
                    
                    // åº”ç”¨èƒŒæ™¯æ ·å¼åˆ°æ§ä»¶
                    currentBgType = savedConfig.backgroundType || 'solid';
                    controls.bgColor.value = extractRgbColor(savedConfig.backgroundColor) || '#ffffff';
                    controls.bgOpacity.value = savedConfig.backgroundOpacity || 1;
                    controls.gradientColor1.value = extractRgbColor(savedConfig.gradientColor1) || '#a5b4fc';
                    controls.gradientColor2.value = extractRgbColor(savedConfig.gradientColor2) || '#e0e7ff';
                    controls.gradientAngle.value = savedConfig.gradientAngle || 145;
                    
                    // åˆ‡æ¢èƒŒæ™¯ç±»å‹UI
                    console.log(`åŠ è½½${type}æ°”æ³¡é…ç½®: èƒŒæ™¯ç±»å‹=${currentBgType}, æ¸å˜è‰²1=${controls.gradientColor1.value}, æ¸å˜è‰²2=${controls.gradientColor2.value}`);
                    
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.checked = true;
                        controls.bgTypeSolid.checked = false;
                        // ä½¿ç”¨CSSç±»æ§åˆ¶æ˜¾ç¤º/éšè—ï¼Œè€Œä¸æ˜¯styleå±æ€§
                        controls.solidBgControls.classList.add('hidden');
                        controls.gradientBgControls.classList.remove('hidden');
                        // åŒæ—¶æ›´æ–°æŒ‰é’®æ ·å¼
                        controls.bgTypeGradient.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeSolid.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    } else {
                        controls.bgTypeSolid.checked = true;
                        controls.bgTypeGradient.checked = false;
                        // ä½¿ç”¨CSSç±»æ§åˆ¶æ˜¾ç¤º/éšè—
                        controls.solidBgControls.classList.remove('hidden');
                        controls.gradientBgControls.classList.add('hidden');
                        // åŒæ—¶æ›´æ–°æŒ‰é’®æ ·å¼
                        controls.bgTypeSolid.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeGradient.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    }
                    
                    // æ–‡æœ¬å†…å®¹å§‹ç»ˆä½¿ç”¨é»˜è®¤å€¼ï¼Œä¸ä»é…ç½®ä¸­åŠ è½½
                    const defaultText = type === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                    
                    // æ›´æ–°å€¼æ˜¾ç¤ºæ ‡ç­¾
                    controls.borderWidthValue.textContent = `${controls.borderWidth.value}px`;
                    controls.borderRadiusValue.textContent = `${controls.borderRadius.value}px`;
                    controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                    controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
                    
                    // ç¡®ä¿å…¨å±€å˜é‡ä¸UIæ§ä»¶çŠ¶æ€åŒæ­¥
                    currentBgType = savedConfig.backgroundType || 'solid';
                    console.log(`${type}æ°”æ³¡é…ç½®åº”ç”¨å®Œæˆ: currentBgType=${currentBgType}`);
                    
                } else {
                    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    console.log(`ä½¿ç”¨${type === 'self' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}æ°”æ³¡é»˜è®¤é…ç½®`);
                    
                    // è®¾ç½®é»˜è®¤å€¼
                    controls.borderWidth.value = 1;
                    controls.borderColor.value = '#4f46e5';
                    controls.borderRadius.value = 12;
                    controls.textColor.value = type === 'self' ? '#ffffff' : '#333333';
                    controls.fontFamily.value = 'Inter';
                    
                    currentBgType = 'solid';
                    controls.bgColor.value = type === 'self' ? '#87CEEB' : '#ffffff';
                    controls.bgOpacity.value = 1;
                    controls.gradientColor1.value = '#a5b4fc';
                    controls.gradientColor2.value = '#e0e7ff';
                    controls.gradientAngle.value = 145;
                    
                    controls.bgTypeSolid.click();
                    
                    // æ–‡æœ¬å†…å®¹å§‹ç»ˆä½¿ç”¨é»˜è®¤å€¼
                    const defaultText = type === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                }
                
                // æ›´æ–°æ ·å¼æ˜¾ç¤º
                updateBubbleStyle();
                
                console.log(`${type}æ°”æ³¡é…ç½®åŠ è½½å®Œæˆï¼ŒUIæ§ä»¶å·²æ›´æ–°`);
            }

            function openProcessor() { 
                imageProcessorModal.style.display = 'flex'; 
                populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error)); 
            }
            function closeProcessor() { 
                imageProcessorModal.style.display = 'none'; 
                renderStickerLibrary().catch(error => console.error('æ¸²æŸ“è´´å›¾åº“å¤±è´¥:', error)); 
            }

            async function handleStickerUpload(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                try {
                    showToast('æ­£åœ¨ä¸Šä¼ è´´å›¾...');
                    
                    for (const file of files) {
                        // æ£€æŸ¥æ–‡ä»¶ç±»å‹ï¼šæ”¯æŒå¸¸è§å›¾ç‰‡æ ¼å¼å’ŒSVG
                        const supportedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'];
                        const isSupported = supportedTypes.includes(file.type) || 
                                          file.name.toLowerCase().endsWith('.svg') ||
                                          file.type.startsWith('image/');
                        
                        if (!isSupported) {
                            console.warn('è·³è¿‡ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼:', file.name, file.type);
                            continue;
                        }
                        
                        // æ–‡ä»¶å¤§å°é™åˆ¶ï¼š5MBï¼ŒSVGå¯ä»¥é€‚å½“æ”¾å®½åˆ°10MB
                        const maxSize = file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg') 
                                      ? 10 * 1024 * 1024  // SVG: 10MB
                                      : 5 * 1024 * 1024;   // å…¶ä»–å›¾ç‰‡: 5MB
                        
                        if (file.size > maxSize) {
                            const sizeLimitMB = maxSize / (1024 * 1024);
                            showToast(`æ–‡ä»¶ ${file.name} è¶…è¿‡ ${sizeLimitMB}MB å¤§å°é™åˆ¶`);
                            continue;
                        }
                        
                        // ç”Ÿæˆå”¯ä¸€ID
                        const stickerId = 'sticker_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        
                        if (fileStorageManager) {
                            // ç›´æ¥ä½¿ç”¨FileStorageManagerå­˜å‚¨æ–‡ä»¶åˆ°IndexedDB
                            try {
                                const storeResult = await fileStorageManager.storeFile(file, {
                                    category: 'bubble_sticker',
                                    originalName: file.name
                                });
                                
                                // storeResult æ˜¯ä¸€ä¸ªå¯¹è±¡ {fileId, type, size}ï¼Œæˆ‘ä»¬éœ€è¦ fileId
                                const actualFileId = storeResult.fileId;
                                console.log('å­˜å‚¨ç»“æœ:', storeResult, 'å®é™…fileId:', actualFileId, 'ç±»å‹:', typeof actualFileId);
                                
                                // åˆ›å»ºæ–‡ä»¶å¼•ç”¨
                                await fileStorageManager.createFileReference(
                                    actualFileId,
                                    'bubble_sticker',
                                    stickerId,
                                    {
                                        originalName: file.name,
                                        fileType: storeResult.type,
                                        fileSize: storeResult.size
                                    }
                                );
                                
                                // åˆ›å»ºè´´å›¾è®°å½•ï¼ˆä¿å­˜fileIdå­—ç¬¦ä¸²ï¼Œç”¨äºè·å–fileSystemå¼•ç”¨ï¼‰
                                const newSticker = {
                                    id: stickerId,
                                    fileId: actualFileId,
                                    originalName: file.name,
                                    fileType: storeResult.type,
                                    fileSize: storeResult.size,
                                    createdAt: new Date().toISOString()
                                };
                                
                                stickerLibrary.push(newSticker);
                                console.log('è´´å›¾å­˜å‚¨æˆåŠŸ(IndexedDB+FileSystem):', newSticker);
                                
                            } catch (error) {
                                console.error('FileStorageManagerå­˜å‚¨å¤±è´¥ï¼Œå›é€€åˆ°base64:', error);
                                // å›é€€åˆ°base64å­˜å‚¨
                                await handleStickerUploadFallback(file, stickerId);
                            }
                        } else {
                            // å›é€€åˆ°base64å­˜å‚¨
                            await handleStickerUploadFallback(file, stickerId);
                        }
                    }
                    
                    await saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                    showToast(`æˆåŠŸä¸Šä¼  ${files.length} ä¸ªè´´å›¾`, 'success');
                    
                } catch (error) {
                    console.error('è´´å›¾ä¸Šä¼ å¤±è´¥:', error);
                    
                    // ä½¿ç”¨è¯¦ç»†çš„é”™è¯¯å¤„ç†é€»è¾‘
                    if (error && error.name === 'DetailedError') {
                        switch(error.code) {
                            case 'FILE_MISSING':
                            case 'PARAM_MISSING':
                                showToast(error.message, 'warning');
                                break;
                            case 'FILE_TOO_LARGE':
                            case 'INVALID_FILE_TYPE':
                                showToast(error.message, 'error');
                                break;
                            case 'STORAGE_FULL':
                                showToast(error.message, 'error');
                                break;
                            case 'DATABASE_ERROR':
                                showToast(error.message, 'error');
                                break;
                            case 'SYSTEM_ERROR':
                                showToast(error.message, 'warning');
                                break;
                            default:
                                showToast(error.message, 'error');
                                break;
                        }
                    } else {
                        showToast('è´´å›¾ä¸Šä¼ å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                    }
                }
                
                event.target.value = '';
            }
            
            // å›é€€åˆ°base64å­˜å‚¨çš„å‡½æ•°
            async function handleStickerUploadFallback(file, stickerId) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const newSticker = {
                            id: stickerId,
                            baseSrc: e.target.result,
                            currentSrc: e.target.result,
                            originalName: file.name,
                            fileType: file.type,
                            fileSize: file.size,
                            createdAt: new Date().toISOString(),
                            isBase64: true // æ ‡è®°ä¸ºbase64å­˜å‚¨
                        };
                        stickerLibrary.push(newSticker);
                        console.log('è´´å›¾base64å­˜å‚¨æˆåŠŸ:', newSticker);
                        resolve();
                    };
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(file);
                });
            }
            
            // SVGä»£ç å¤„ç†å‡½æ•°
            function validateSvgCode(svgCode) {
                // åŸºæœ¬éªŒè¯ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«svgæ ‡ç­¾
                const svgRegex = /<svg[\s\S]*?<\/svg>/i;
                if (!svgRegex.test(svgCode)) {
                    return { valid: false, error: 'SVGä»£ç å¿…é¡»åŒ…å«å®Œæ•´çš„<svg>...</svg>æ ‡ç­¾' };
                }
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«æ½œåœ¨çš„å±é™©å†…å®¹ï¼ˆåŸºç¡€å®‰å…¨æ£€æŸ¥ï¼‰
                const dangerousPatterns = [
                    /<script/i,
                    /javascript:/i,
                    /on\w+\s*=/i,  // onclick, onloadç­‰äº‹ä»¶
                ];
                
                for (const pattern of dangerousPatterns) {
                    if (pattern.test(svgCode)) {
                        return { valid: false, error: 'SVGä»£ç åŒ…å«ä¸å®‰å…¨çš„å†…å®¹' };
                    }
                }
                
                return { valid: true };
            }
            
            function normalizeSvgCode(svgCode) {
                // æ¸…ç†å’Œè§„èŒƒåŒ–SVGä»£ç 
                let cleaned = svgCode.trim();
                
                // å¦‚æœæ²¡æœ‰XMLå£°æ˜ï¼Œç¡®ä¿SVGæœ‰æ­£ç¡®çš„å‘½åç©ºé—´
                if (!cleaned.includes('xmlns=')) {
                    cleaned = cleaned.replace(
                        /<svg/i, 
                        '<svg xmlns="http://www.w3.org/2000/svg"'
                    );
                }
                
                // å¦‚æœæ²¡æœ‰viewBoxï¼Œå°è¯•ä»width/heightç”Ÿæˆä¸€ä¸ª
                if (!cleaned.includes('viewBox') && cleaned.includes('width=') && cleaned.includes('height=')) {
                    const widthMatch = cleaned.match(/width="?(\d+)"?/i);
                    const heightMatch = cleaned.match(/height="?(\d+)"?/i);
                    if (widthMatch && heightMatch) {
                        const width = widthMatch[1];
                        const height = heightMatch[1];
                        cleaned = cleaned.replace(
                            /<svg([^>]*)>/i,
                            `<svg$1 viewBox="0 0 ${width} ${height}">`
                        );
                    }
                }
                
                return cleaned;
            }
            
            async function handleSvgCodeInput() {
                const svgCode = controls.svgCodeInput.value.trim();
                
                if (!svgCode) {
                    showToast('è¯·è¾“å…¥SVGä»£ç ');
                    return;
                }
                
                try {
                    // éªŒè¯SVGä»£ç 
                    const validation = validateSvgCode(svgCode);
                    if (!validation.valid) {
                        showToast('é”™è¯¯: ' + validation.error);
                        return;
                    }
                    
                    // è§„èŒƒåŒ–SVGä»£ç 
                    const normalizedSvg = normalizeSvgCode(svgCode);
                    
                    // åˆ›å»ºSVG Blob
                    const svgBlob = new Blob([normalizedSvg], { type: 'image/svg+xml' });
                    
                    // æ£€æŸ¥å¤§å°é™åˆ¶ (10MB)
                    if (svgBlob.size > 10 * 1024 * 1024) {
                        showToast('SVGä»£ç è¿‡å¤§ï¼Œè¯·å°è¯•ç®€åŒ–');
                        return;
                    }
                    
                    showToast('æ­£åœ¨æ·»åŠ SVGè´´å›¾...');
                    
                    // ç”Ÿæˆå”¯ä¸€ID
                    const stickerId = 'sticker_svg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    if (fileStorageManager) {
                        try {
                            // ä½¿ç”¨FileStorageManagerå­˜å‚¨SVG
                            const storeResult = await fileStorageManager.storeFile(svgBlob, {
                                category: 'bubble_sticker',
                                originalName: `svg_${Date.now()}.svg`,
                                isUserCreated: true
                            });
                            
                            const actualFileId = typeof storeResult.fileId === 'string' 
                                               ? storeResult.fileId 
                                               : String(storeResult.fileId);
                            
                            // åˆ›å»ºæ–‡ä»¶å¼•ç”¨
                            await fileStorageManager.createFileReference(
                                actualFileId,
                                'bubble_sticker',
                                stickerId,
                                {
                                    originalName: `svg_${Date.now()}.svg`,
                                    fileType: 'image/svg+xml',
                                    isUserCreated: true
                                }
                            );
                            
                            // åˆ›å»ºè´´å›¾è®°å½•
                            const newSticker = {
                                id: stickerId,
                                fileId: actualFileId,
                                originalName: `svg_${Date.now()}.svg`,
                                fileType: 'image/svg+xml',
                                fileSize: svgBlob.size,
                                createdAt: new Date().toISOString(),
                                isUserCreated: true
                            };
                            
                            stickerLibrary.push(newSticker);
                            console.log('SVGè´´å›¾å­˜å‚¨æˆåŠŸ(IndexedDB+FileSystem):', newSticker);
                            
                        } catch (error) {
                            console.error('FileStorageManagerå­˜å‚¨å¤±è´¥ï¼Œå›é€€åˆ°base64:', error);
                            // å›é€€åˆ°base64å­˜å‚¨
                            await handleSvgFallbackStorage(normalizedSvg, stickerId);
                        }
                    } else {
                        // å›é€€åˆ°base64å­˜å‚¨
                        await handleSvgFallbackStorage(normalizedSvg, stickerId);
                    }
                    
                    // ä¿å­˜å’Œæ›´æ–°ç•Œé¢
                    await saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                    showToast('SVGè´´å›¾æ·»åŠ æˆåŠŸï¼');
                    
                    // æ¸…ç©ºè¾“å…¥æ¡†
                    controls.svgCodeInput.value = '';
                    
                } catch (error) {
                    console.error('SVGå¤„ç†å¤±è´¥:', error);
                    showToast('SVGå¤„ç†å¤±è´¥: ' + error.message);
                }
            }
            
            async function handleSvgFallbackStorage(svgCode, stickerId) {
                // è½¬æ¢ä¸ºdata URL
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgCode)));
                
                const newSticker = {
                    id: stickerId,
                    baseSrc: dataUrl,
                    currentSrc: dataUrl,
                    originalName: `svg_${Date.now()}.svg`,
                    fileType: 'image/svg+xml',
                    fileSize: svgCode.length,
                    createdAt: new Date().toISOString(),
                    isBase64: true,
                    isUserCreated: true
                };
                
                stickerLibrary.push(newSticker);
                console.log('SVGè´´å›¾base64å­˜å‚¨æˆåŠŸ:', newSticker);
            }
            
            async function populateStickerGallery() {
                stickerGallery.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const container = document.createElement('div');
                    container.className = 'relative group';
                    
                    const img = document.createElement('img');
                    img.className = 'w-full h-full object-contain bg-slate-200 rounded-md cursor-pointer hover:ring-2 ring-indigo-500';
                    img.dataset.id = sticker.id;
                    img.addEventListener('click', () => selectStickerForEditing(sticker.id));
                    
                    // è·å–å›¾ç‰‡URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            // ä½¿ç”¨FileStorageManagerè·å–fileSystemå¼•ç”¨URL
                            console.log('å°è¯•è·å–å›¾ç‰‡URLï¼ŒfileId:', sticker.fileId, 'ç±»å‹:', typeof sticker.fileId);
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            // å›é€€åˆ°base64
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('è´´å›¾æ— æœ‰æ•ˆçš„å›¾ç‰‡æº:', sticker);
                            imageUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4='; // å ä½ç¬¦SVG
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('è·å–è´´å›¾URLå¤±è´¥:', error);
                        img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4=';
                    }
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition-opacity z-10';
                    deleteBtn.addEventListener('click', async (e) => { 
                        e.stopPropagation(); 
                        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè´´çº¸å—ï¼Ÿæ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ–‡ä»¶ä¸”æ— æ³•æ¢å¤ã€‚')) {
                            await deleteSticker(sticker.id); 
                        }
                    });
                    
                    container.appendChild(img);
                    container.appendChild(deleteBtn);
                    stickerGallery.appendChild(container);
                }
            }
            
            async function deleteSticker(id) {
                // é¦–å…ˆè·å–è¦åˆ é™¤çš„è´´çº¸ä¿¡æ¯ï¼Œä»¥ä¾¿æ¸…ç†æ–‡ä»¶å­˜å‚¨
                const stickerToDelete = stickerLibrary.find(s => s.id === id);
                
                if (stickerToDelete && stickerToDelete.fileId && fileStorageManager) {
                    try {
                        console.log('æ¸…ç†è´´çº¸æ–‡ä»¶å­˜å‚¨ï¼ŒstickerId:', id, 'fileId:', stickerToDelete.fileId);
                        
                        // åˆ é™¤æ–‡ä»¶å¼•ç”¨
                        await fileStorageManager.deleteFileReference('bubble_sticker_' + id);
                        console.log('æ–‡ä»¶å¼•ç”¨åˆ é™¤æˆåŠŸ');
                        
                        // åˆ é™¤å®é™…æ–‡ä»¶ï¼ˆFileStorageManagerä¼šæ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–å¼•ç”¨ï¼‰
                        await fileStorageManager.deleteFile(stickerToDelete.fileId);
                        console.log('æ–‡ä»¶å­˜å‚¨åˆ é™¤æˆåŠŸ');
                        
                    } catch (error) {
                        console.error('æ¸…ç†æ–‡ä»¶å­˜å‚¨å¤±è´¥:', error);
                        // å³ä½¿æ–‡ä»¶å­˜å‚¨æ¸…ç†å¤±è´¥ï¼Œä¹Ÿç»§ç»­åˆ é™¤è´´çº¸è®°å½•
                    }
                }
                
                // ä»è´´çº¸åº“ä¸­ç§»é™¤
                stickerLibrary = stickerLibrary.filter(s => s.id != id);
                saveStickerLibraryToStorage();
                populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                
                if (currentEditingStickerId == id) {
                    currentEditingStickerId = null;
                    editorPlaceholder.classList.remove('hidden');
                    editorControls.classList.add('hidden');
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                }
            }

            async function renderStickerLibrary() {
                stickerLibraryContainer.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const img = document.createElement('img');
                    img.className = 'library-sticker';
                    img.dataset.id = sticker.id;
                    
                    // è·å–å›¾ç‰‡URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('è´´å›¾æ— æœ‰æ•ˆçš„å›¾ç‰‡æº:', sticker);
                            continue; // è·³è¿‡æ— æ•ˆè´´å›¾
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('è·å–è´´å›¾URLå¤±è´¥:', error);
                        continue; // è·³è¿‡å¤±è´¥çš„è´´å›¾
                    }
                    
                    makeLibraryStickerDraggable(img);
                    stickerLibraryContainer.appendChild(img);
                }
            }

            function selectStickerForEditing(id) {
                currentEditingStickerId = id;
                const sticker = stickerLibrary.find(s => s.id == id);
                if (!sticker) return;
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºSVGæ–‡ä»¶
                const isSVG = sticker.fileType === 'image/svg+xml' || 
                            sticker.originalName?.toLowerCase().endsWith('.svg');
                
                editorPlaceholder.classList.add('hidden');
                editorControls.classList.remove('hidden');
                
                // å¦‚æœæ˜¯SVGæ–‡ä»¶ï¼Œç¦ç”¨èƒŒæ™¯ç§»é™¤ç›¸å…³åŠŸèƒ½
                const removeBgBtn = document.getElementById('removeBgBtn');
                const toleranceContainer = document.querySelector('#editorControls .space-y-2:nth-child(2)');
                
                if (isSVG) {
                    if (removeBgBtn) removeBgBtn.style.display = 'none';
                    if (toleranceContainer) toleranceContainer.style.display = 'none';
                    // æ˜¾ç¤ºSVGæç¤ºä¿¡æ¯
                    const existingNotice = document.getElementById('svgEditNotice');
                    if (!existingNotice) {
                        const notice = document.createElement('div');
                        notice.id = 'svgEditNotice';
                        notice.className = 'text-sm text-slate-600 bg-slate-100 p-2 rounded';
                        notice.textContent = 'SVGæ–‡ä»¶ä¸æ”¯æŒèƒŒæ™¯ç§»é™¤åŠŸèƒ½';
                        removeBgBtn.parentNode.insertBefore(notice, removeBgBtn);
                    }
                } else {
                    if (removeBgBtn) removeBgBtn.style.display = 'block';
                    if (toleranceContainer) toleranceContainer.style.display = 'block';
                    // ç§»é™¤SVGæç¤ºä¿¡æ¯
                    const existingNotice = document.getElementById('svgEditNotice');
                    if (existingNotice) existingNotice.remove();
                }
                
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.currentSrc || sticker.baseSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    ctx.drawImage(img, 0, 0);
                }
            }
            
            function processImage(colorToRemove, tolerance) {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (!sticker) return;
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.baseSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    const data = imageData.data;
                    const [tr, tg, tb] = colorToRemove;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const distance = Math.sqrt(Math.pow(r - tr, 2) + Math.pow(g - tg, 2) + Math.pow(b - tb, 2));
                        if (distance < tolerance) { data[i + 3] = 0; }
                    }
                    ctx.putImageData(imageData, 0, 0);
                };
            }

            // è·å–è´´å›¾URLçš„è¾…åŠ©å‡½æ•°
            async function getStickerImageURL(sticker) {
                try {
                    if (sticker.fileId && fileStorageManager) {
                        return await fileStorageManager.createFileURL(sticker.fileId);
                    } else if (sticker.currentSrc || sticker.baseSrc) {
                        return sticker.currentSrc || sticker.baseSrc;
                    } else {
                        console.warn('è´´å›¾æ— æœ‰æ•ˆçš„å›¾ç‰‡æº:', sticker);
                        return null;
                    }
                } catch (error) {
                    console.error('è·å–è´´å›¾URLå¤±è´¥:', error);
                    return sticker.currentSrc || sticker.baseSrc || null;
                }
            }

            function makeLibraryStickerDraggable(element) {
                element.addEventListener('mousedown', async (e) => {
                    e.preventDefault();
                    
                    if (currentThemeName === 'default') {
                        showToast('é»˜è®¤ä¸»é¢˜ä¸æ”¯æŒæ·»åŠ è´´çº¸ï¼Œè¯·æ–°å»ºä¸»é¢˜åä½¿ç”¨', 'info');
                        return;
                    }
                    
                    const stickerData = stickerLibrary.find(s => s.id == element.dataset.id);
                    if (!stickerData) return;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = zIndexCounter++; 
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // å¼‚æ­¥è·å–å›¾ç‰‡URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (!imageUrl) {
                        console.error('æ— æ³•è·å–è´´å›¾URLï¼Œè·³è¿‡åˆ›å»º');
                        return;
                    }
                    newSticker.src = imageUrl;
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    
                    // æ ¹æ®å½“å‰é€‰æ‹©çš„æ°”æ³¡ç±»å‹æ·»åŠ è´´å›¾
                    const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                    targetBubble.appendChild(wrapper);

                    const bubbleRect = targetBubble.getBoundingClientRect();
                    const initialWidth = 120;
                    wrapper.style.width = `${initialWidth}px`;
                    const tempImg = new Image();
                    tempImg.src = imageUrl;
                    tempImg.onload = () => {
                        const aspectRatio = tempImg.naturalHeight / tempImg.naturalWidth;
                        wrapper.style.height = `${initialWidth * aspectRatio}px`;
                        wrapper.style.left = `${(bubbleRect.width - wrapper.offsetWidth) / 2}px`;
                        wrapper.style.top = `${(bubbleRect.height - wrapper.offsetHeight) / 2}px`;
                    };
                    
                    makePlacedStickerInteractive(wrapper);
                    
                    // æ·»åŠ è´´çº¸åæ›´æ–°äº¤äº’çŠ¶æ€
                    updateStickersInteractionState();
                });
            }
            
            function makePlacedStickerInteractive(wrapper) {
                const resizeHandle = wrapper.querySelector('.resize-handle');
                let isDragging = false, isResizing = false;
                let offsetX, offsetY;

                function getCurrentBubbleContainer() {
                    // è·å–å½“å‰é€‰ä¸­çš„æ°”æ³¡å®¹å™¨
                    const currentType = getCurrentBubbleType();
                    return currentType === 'self' ? previewBubbleSelf : previewBubbleKare;
                }

                function isCurrentBubbleSticker() {
                    // æ£€æŸ¥è¿™ä¸ªè´´çº¸æ˜¯å¦å±äºå½“å‰é€‰ä¸­çš„æ°”æ³¡
                    const currentBubble = getCurrentBubbleContainer();
                    return currentBubble.contains(wrapper);
                }

                function onMoveDown(e) {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸äº¤äº’
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    isDragging = true;
                    wrapper.classList.add('dragging');
                    const event = e.touches ? e.touches[0] : e;
                    const rect = wrapper.getBoundingClientRect();
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    offsetX = event.clientX - rect.left;
                    offsetY = event.clientY - rect.top;
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onMoveUp);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onMoveUp);
                }
                function onMove(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    const event = e.touches ? e.touches[0] : e;
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    wrapper.style.left = `${event.clientX - bubbleRect.left - offsetX}px`;
                    wrapper.style.top = `${event.clientY - bubbleRect.top - offsetY}px`;
                }
                function onMoveUp() {
                    isDragging = false;
                    wrapper.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onMoveUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onMoveUp);
                }
                wrapper.addEventListener('mousedown', onMoveDown);
                wrapper.addEventListener('touchstart', onMoveDown, { passive: false });

                function onResizeDown(e) {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸äº¤äº’
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    isResizing = true;
                    const event = e.touches ? e.touches[0] : e;
                    const initialWidth = wrapper.offsetWidth;
                    const initialHeight = wrapper.offsetHeight;
                    const initialX = event.clientX;
                    const initialY = event.clientY;

                    function onResizeMove(e) {
                        if (!isResizing) return;
                        const event = e.touches ? e.touches[0] : e;
                        const deltaX = event.clientX - initialX;
                        const deltaY = event.clientY - initialY;
                        const newWidth = Math.max(20, initialWidth + deltaX);
                        const newHeight = Math.max(20, initialHeight + deltaY);
                        wrapper.style.width = `${newWidth}px`;
                        wrapper.style.height = `${newHeight}px`;
                    }

                    function onResizeUp() {
                        isResizing = false;
                        document.removeEventListener('mousemove', onResizeMove);
                        document.removeEventListener('mouseup', onResizeUp);
                        document.removeEventListener('touchmove', onResizeMove);
                        document.removeEventListener('touchend', onResizeUp);
                    }
                    
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeUp);
                    document.addEventListener('touchmove', onResizeMove, { passive: false });
                    document.addEventListener('touchend', onResizeUp);
                }
                resizeHandle.addEventListener('mousedown', onResizeDown);
                resizeHandle.addEventListener('touchstart', onResizeDown, { passive: false });

                wrapper.addEventListener('dblclick', () => {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸åˆ é™¤
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    wrapper.remove();
                    showToast('è´´å›¾å·²ç§»é™¤');
                });

                wrapper.addEventListener('click', (e) => {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸è¢«é€‰æ‹©
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    selectSticker(wrapper);
                });
            }

            function selectSticker(wrapper) {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.remove('selected');
                }
                selectedStickerWrapper = wrapper;
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.add('selected');
                    controls.sendToBackBtn.disabled = false;
                    controls.bringToFrontBtn.disabled = false;
                } else {
                    controls.sendToBackBtn.disabled = true;
                    controls.bringToFrontBtn.disabled = true;
                }
            }
            previewContainer.addEventListener('click', (e) => {
                if (e.target === previewContainer || e.target === previewBubbleSelf || e.target === previewBubbleKare) {
                    selectSticker(null);
                }
            });

            controls.sendToBackBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = 1;
                    showToast('å·²ç½®äºæ–‡å­—åº•å±‚');
                }
            });
            controls.bringToFrontBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = zIndexCounter++;
                    showToast('å·²ç½®äºæ–‡å­—é¡¶å±‚');
                }
            });


            controls.manageStickersBtn.addEventListener('click', openProcessor);
            controls.closeProcessorBtn.addEventListener('click', closeProcessor);
            controls.galleryStickerUpload.addEventListener('change', handleStickerUpload);
            
            // SVGä»£ç è¾“å…¥ç›¸å…³äº‹ä»¶
            controls.toggleSvgInputBtn.addEventListener('click', () => {
                const isHidden = controls.svgInputSection.classList.contains('hidden');
                if (isHidden) {
                    controls.svgInputSection.classList.remove('hidden');
                    controls.toggleSvgInputBtn.textContent = 'éšè—SVGè¾“å…¥';
                } else {
                    controls.svgInputSection.classList.add('hidden');
                    controls.toggleSvgInputBtn.textContent = 'è¾“å…¥SVGä»£ç ';
                }
            });
            
            controls.addSvgBtn.addEventListener('click', handleSvgCodeInput);
            controls.clearSvgBtn.addEventListener('click', () => {
                controls.svgCodeInput.value = '';
                showToast('å·²æ¸…ç©ºSVGä»£ç ');
            });
            
            // æ”¯æŒCtrl+Enterå¿«æ·é”®æäº¤SVG
            controls.svgCodeInput.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    handleSvgCodeInput();
                }
            });
            controls.removeBgBtn.addEventListener('click', () => imageEditorCanvas.classList.add('dropper-cursor'));
            imageEditorCanvas.addEventListener('click', (e) => {
                if (!imageEditorCanvas.classList.contains('dropper-cursor')) return;
                const rect = imageEditorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                targetColor = [pixel[0], pixel[1], pixel[2]];
                imageEditorCanvas.classList.remove('dropper-cursor');
                processImage(targetColor, controls.tolerance.value);
            });
            controls.tolerance.addEventListener('input', () => {
                controls.toleranceValue.textContent = controls.tolerance.value;
                if (currentEditingStickerId && targetColor) {
                    processImage(targetColor, controls.tolerance.value);
                }
            });
            controls.saveChangesBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = imageEditorCanvas.toDataURL();
                    saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                }
            });
            controls.resetStickerBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = sticker.baseSrc;
                    saveStickerLibraryToStorage();
                    selectStickerForEditing(sticker.id);
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                }
            });

            // ã€ä¿®æ”¹ã€‘å°† textColor å’Œ fontFamily æ·»åŠ åˆ°äº‹ä»¶ç›‘å¬å¾ªç¯ä¸­
            ['borderWidth', 'borderColor', 'borderRadius', 'bgColor', 'bgOpacity', 'gradientColor1', 'gradientColor2', 'gradientAngle', 'textColor', 'fontFamily'].forEach(id => { if (controls[id]) { controls[id].addEventListener('input', updateBubbleStyle); } });
            controls.bubbleText.addEventListener('input', () => { 
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                currentTextContent.textContent = controls.bubbleText.value; 
            });
            controls.bgTypeSolid.addEventListener('click', () => { currentBgType = 'solid'; controls.solidBgControls.classList.remove('hidden'); controls.gradientBgControls.classList.add('hidden'); controls.bgTypeSolid.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.remove('text-slate-600'); controls.bgTypeGradient.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.add('text-slate-600'); updateBubbleStyle(); });
            controls.bgTypeGradient.addEventListener('click', () => { currentBgType = 'gradient'; controls.solidBgControls.classList.add('hidden'); controls.gradientBgControls.classList.remove('hidden'); controls.bgTypeGradient.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.remove('text-slate-600'); controls.bgTypeSolid.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.add('text-slate-600'); updateBubbleStyle(); });

            // æ°”æ³¡ç±»å‹åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
            controls.bubbleTypeSelf.addEventListener('click', () => switchBubbleType('self'));
            controls.bubbleTypeKare.addEventListener('click', () => switchBubbleType('kare'));
            
            // CSSæ ·å¼è§£æè¾…åŠ©å‡½æ•°
            function extractRgbColor(colorValue) {
                if (!colorValue) return '#ffffff';
                // å¦‚æœæ˜¯rgb/rgbaæ ¼å¼ï¼Œæå–RGBéƒ¨åˆ†
                const match = colorValue.match(/rgba?\(([^)]+)\)/);
                if (match) {
                    const values = match[1].split(',').map(v => parseInt(v.trim()));
                    return `#${values.slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')}`;
                }
                // å¦‚æœå·²ç»æ˜¯hexæ ¼å¼ï¼Œç›´æ¥è¿”å›
                if (colorValue.startsWith('#')) return colorValue;
                return '#ffffff';
            }

            function extractAlpha(colorValue) {
                if (!colorValue) return 1;
                const match = colorValue.match(/rgba?\([^,]+,[^,]+,[^,]+,?\s*([^)]*)\)/);
                if (match && match[1]) {
                    return parseFloat(match[1]) || 1;
                }
                return 1;
            }

            function extractGradientColors(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return ['#ffffff', '#ffffff'];
                }
                // åŒ¹é…gradientä¸­çš„é¢œè‰²
                const colorMatches = backgroundValue.match(/(#[0-9a-fA-F]{6}|rgb\([^)]+\)|rgba\([^)]+\))/g);
                if (colorMatches && colorMatches.length >= 2) {
                    return [extractRgbColor(colorMatches[0]), extractRgbColor(colorMatches[1])];
                }
                return ['#ffffff', '#ffffff'];
            }

            function extractGradientAngle(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return 0;
                }
                const angleMatch = backgroundValue.match(/(\d+)deg/);
                return angleMatch ? parseInt(angleMatch[1]) : 0;
            }

            // ä¸ºæŒ‡å®šæ°”æ³¡ç±»å‹ç”Ÿæˆå®Œæ•´é…ç½®
            function generateBubbleConfig(bubbleType) {
                const targetBubble = bubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                const targetTextContent = bubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                const bubbleStyle = window.getComputedStyle(targetBubble);
                const textStyle = window.getComputedStyle(targetTextContent);
                
                // ç”Ÿæˆè´´çº¸HTML
                let htmlStickers = '';
                const bubbleWidth = targetBubble.offsetWidth;
                const bubbleHeight = targetBubble.offsetHeight;

                targetBubble.querySelectorAll('.sticker-wrapper').forEach((stickerWrapper, index) => {
                    const stickerImg = stickerWrapper.querySelector('.sticker-image');
                    const stickerId = stickerWrapper.dataset.id;
                    const stickerData = stickerLibrary.find(s => s.id == stickerId);
                    const stickerSrc = stickerImg.src;

                    const leftPx = parseFloat(stickerWrapper.style.left) || 0;
                    const topPx = parseFloat(stickerWrapper.style.top) || 0;
                    const stickerWidth = stickerWrapper.offsetWidth;
                    const stickerHeight = stickerWrapper.offsetHeight;

                    const leftPercent = (leftPx + stickerWidth / 2) / bubbleWidth;
                    const topPercent = (topPx + stickerHeight / 2) / bubbleHeight;
                    
                    let positionStyle = '';
                    if (leftPercent < 0.33 && topPercent < 0.33) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent < 0.33) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent < 0.33 && topPercent > 0.67) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent > 0.67) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else {
                        positionStyle = `left: ${((leftPx + stickerWidth / 2) / bubbleWidth * 100).toFixed(1)}%; top: ${((topPx + stickerHeight / 2) / bubbleHeight * 100).toFixed(1)}%; transform: translate(-50%, -50%);`;
                    }
                    
                    htmlStickers += `    <img src="${stickerSrc}" class="sticker-${index}" alt="sticker" style="position: absolute; ${positionStyle} width: ${stickerWidth.toFixed(0)}px; height: ${stickerHeight.toFixed(0)}px; z-index: ${stickerWrapper.style.zIndex || 1}; user-select: none; pointer-events: none;">\\n`;
                });

                const htmlTemplate = `<div class="chat-bubble" style="background: ${bubbleStyle.background || bubbleStyle.backgroundColor}; border: ${bubbleStyle.border}; border-radius: ${bubbleStyle.borderRadius}; padding: 12px; margin-bottom: 8px; max-width: 80%; word-wrap: break-word; position: relative; color: ${textStyle.color}; font-family: ${textStyle.fontFamily};">\\n    {{BUBBLE_TEXT}}\\n${htmlStickers}</div>`;

                return {
                    borderWidth: parseInt(controls.borderWidth.value) || 1,
                    borderColor: controls.borderColor.value || '#4f46e5',
                    borderRadius: parseInt(controls.borderRadius.value) || 12,
                    backgroundColor: controls.bgColor.value || '#ffffff',
                    backgroundOpacity: parseFloat(controls.bgOpacity.value) || 1,
                    backgroundType: currentBgType, // ç›´æ¥ä½¿ç”¨å½“å‰çš„èƒŒæ™¯ç±»å‹ï¼Œè€Œä¸æ˜¯ä»æ ·å¼æ¨æ–­
                    gradientColor1: controls.gradientColor1.value || '#a5b4fc',
                    gradientColor2: controls.gradientColor2.value || '#e0e7ff',  
                    gradientAngle: controls.gradientAngle.value || 145,
                    textColor: controls.textColor.value || '#333333',
                    fontFamily: controls.fontFamily.value || 'Inter',
                    // bubbleText: ä¸ä¿å­˜æ–‡æœ¬å†…å®¹ï¼Œæ¯æ¬¡ä½¿ç”¨é»˜è®¤å€¼
                    stickers: Array.from(targetBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => {
                        const stickerId = wrapper.dataset.id;
                        const stickerInfo = stickerLibrary.find(s => s.id === stickerId);
                        return {
                            id: stickerId,
                            fileId: stickerInfo?.fileId || '',
                            left: parseFloat(wrapper.style.left) || 0,
                            top: parseFloat(wrapper.style.top) || 0,
                            width: wrapper.offsetWidth,
                            height: wrapper.offsetHeight,
                            zIndex: wrapper.style.zIndex || 1
                        };
                    }),
                    html: htmlTemplate,
                    enabled: true
                };
            }

            // å…±äº«çš„ä¿å­˜é…ç½®å‡½æ•°
            async function saveCurrentConfiguration() {
                console.log('å¼€å§‹ä¿å­˜å½“å‰é…ç½®...');
                
                // 1. ç”Ÿæˆå½“å‰é€‰æ‹©æ°”æ³¡ç±»å‹çš„HTMLå’ŒCSSä»£ç ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                const bubbleStyle = window.getComputedStyle(currentBubble);
                const textStyle = window.getComputedStyle(currentTextContent);
                
                // 2. ä¿å­˜å½“å‰UIçŠ¶æ€åˆ°ç¼“å­˜
                uiStateCache[currentBubbleType] = captureCurrentUIState();
                
                // 3. ç”Ÿæˆå¹¶ä¿å­˜åŒæ–¹æ°”æ³¡çš„å®Œæ•´é…ç½®ï¼ˆä»ç¼“å­˜å’Œå½“å‰çŠ¶æ€ï¼‰
                const selfConfig = uiStateCache.self ? uiStateCache.self : captureCurrentUIState();
                const kareConfig = uiStateCache.kare ? uiStateCache.kare : captureCurrentUIState();
                
                // ç”ŸæˆHTMLæ¨¡æ¿ï¼ˆä¸»åº”ç”¨è¦æ±‚å¿…é¡»æœ‰htmlå­—æ®µï¼‰
                const generateHtmlTemplate = (config) => {
                    const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                    
                    // ç”ŸæˆèƒŒæ™¯æ ·å¼
                    let backgroundStyle = '';
                    if (config.backgroundType === 'gradient') {
                        backgroundStyle = `linear-gradient(${config.gradientAngle}deg, ${config.gradientColor1}, ${config.gradientColor2})`;
                    } else {
                        const bgColor = config.backgroundColor || '#ffffff';
                        const opacity = config.backgroundOpacity || 1;
                        // ç®€åŒ–å¤„ç†ï¼Œç›´æ¥ä½¿ç”¨é¢œè‰²å’Œé€æ˜åº¦
                        backgroundStyle = `${bgColor}`;
                        if (opacity < 1) {
                            // å¦‚æœæœ‰é€æ˜åº¦ï¼Œè½¬æ¢ä¸ºrgbaæ ¼å¼
                            const r = parseInt(bgColor.slice(1, 3), 16);
                            const g = parseInt(bgColor.slice(3, 5), 16);
                            const b = parseInt(bgColor.slice(5, 7), 16);
                            backgroundStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                        }
                    }
                    
                    // ç”Ÿæˆè´´çº¸HTML - ä½¿ç”¨fileIdæ ¼å¼ä¾›ä¸»åº”ç”¨è§£æ
                    let stickersHtml = '';
                    if (config.stickers && config.stickers.length > 0) {
                        stickersHtml = config.stickers.map(sticker => 
                            `<img src="file:${sticker.fileId || ''}" class="sticker" data-file-id="${sticker.fileId || ''}" style="position: absolute; left: ${sticker.left || 0}px; top: ${sticker.top || 0}px; width: ${sticker.width || 50}px; height: ${sticker.height || 50}px; z-index: ${sticker.zIndex || 1}; user-select: none; pointer-events: none;">`
                        ).join('');
                    }
                    
                    return `<div class="custom-bubble-container" style="position: relative; padding: 8px 12px; border: ${config.borderWidth}px solid ${config.borderColor}; border-radius: ${config.borderRadius}px; background: ${backgroundStyle};">
    <span class="bubble-text" style="position: relative; z-index: 10; color: ${config.textColor}; font-family: '${config.fontFamily}';">{{BUBBLE_TEXT}}</span>
    ${stickersHtml}
</div>`;
                };
                
                // æ ¼å¼åŒ–é…ç½®ç”¨äºä¿å­˜ï¼ˆåŒ…å«HTMLæ¨¡æ¿ï¼‰
                const formatConfigForSave = (config) => ({
                    borderWidth: parseInt(config.borderWidth) || 1,
                    borderColor: config.borderColor || '#4f46e5',
                    borderRadius: parseInt(config.borderRadius) || 12,
                    backgroundColor: config.backgroundColor || '#ffffff',
                    backgroundOpacity: parseFloat(config.backgroundOpacity) || 1,
                    backgroundType: config.backgroundType || 'solid',
                    gradientColor1: config.gradientColor1 || '#a5b4fc',
                    gradientColor2: config.gradientColor2 || '#e0e7ff',
                    gradientAngle: parseInt(config.gradientAngle) || 145,
                    textColor: config.textColor || '#333333',
                    fontFamily: config.fontFamily || 'Inter',
                    stickers: config.stickers || [],
                    html: generateHtmlTemplate(config), // æ·»åŠ HTMLæ¨¡æ¿
                    css: '/* CSSå·²å†…è”åˆ°HTMLä¸­ */', // æ·»åŠ CSSå­—æ®µ
                    createdAt: new Date().toISOString(),
                    enabled: true
                });
                
                const formattedSelfConfig = formatConfigForSave(selfConfig);
                const formattedKareConfig = formatConfigForSave(kareConfig);
                
                // åŒæ—¶ä¿å­˜åŒæ–¹çš„é…ç½®
                await saveBubbleStyleConfig(formattedSelfConfig, 'bubbleStyleSelf');
                await saveBubbleStyleConfig(formattedKareConfig, 'bubbleStyle');
                
                // å¦‚æœå½“å‰å¤„äºè‡ªå®šä¹‰ä¸»é¢˜ï¼ŒåŒæ—¶æ›´æ–°ä¸»é¢˜æ•°æ®
                if (currentThemeName !== 'default') {
                    try {
                        const themeData = {
                            type: `theme_${currentThemeName}`,
                            name: currentThemeName,
                            updatedAt: new Date().toISOString(),
                            bubbleStyles: {
                                self: formattedSelfConfig,
                                kare: formattedKareConfig
                            },
                            stickerLibrary: stickerLibrary || []
                        };
                        
                        const transaction = db.transaction(['themeConfig'], 'readwrite');
                        const store = transaction.objectStore('themeConfig');
                        
                        await new Promise((resolve, reject) => {
                            const request = store.put(themeData);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        
                        console.log(`ä¸»é¢˜"${currentThemeName}"æ•°æ®å·²åŒæ­¥æ›´æ–°`);
                    } catch (error) {
                        console.error('æ›´æ–°ä¸»é¢˜æ•°æ®å¤±è´¥:', error);
                    }
                }
                
                return { selfConfig: formattedSelfConfig, kareConfig: formattedKareConfig };
            }
            
            // "ä¿å­˜"æŒ‰é’®äº‹ä»¶å¤„ç†å™¨
            controls.saveOnlyBtn.addEventListener('click', async () => {
                try {
                    if (currentThemeName === 'default') {
                        showToast('é»˜è®¤ä¸»é¢˜ä¸å¯ä¿å­˜ï¼ˆåªè¯»æ¨¡å¼ï¼‰', 'info');
                        return;
                    }
                    
                    await saveCurrentConfiguration();
                    
                    showToast('é…ç½®å·²ä¿å­˜ï¼', 'success');
                    const originalText = controls.saveOnlyBtn.textContent;
                    controls.saveOnlyBtn.textContent = 'âœ… å·²ä¿å­˜!';
                    setTimeout(() => {
                        controls.saveOnlyBtn.textContent = originalText;
                    }, 2000);
                } catch (error) {
                    console.error('ä¿å­˜å¤±è´¥:', error);
                    showToast('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
                }
            });
            
            // "ä¿å­˜å¹¶åº”ç”¨"æŒ‰é’®äº‹ä»¶å¤„ç†å™¨  
            controls.generateCodeBtn.addEventListener('click', async () => {
                try {
                    let selfConfig, kareConfig;
                    
                    if (currentThemeName === 'default') {
                        // é»˜è®¤ä¸»é¢˜ï¼šä½¿ç”¨å›ºå®šçš„é»˜è®¤é…ç½®ï¼Œå¹¶ç”ŸæˆHTMLæ¨¡æ¿
                        console.log('åº”ç”¨é»˜è®¤ä¸»é¢˜é…ç½®...');
                        
                        // ä¸ºé»˜è®¤é…ç½®ç”ŸæˆHTMLæ¨¡æ¿
                        const generateHtmlTemplate = (config) => {
                            let backgroundStyle = config.backgroundColor || '#ffffff';
                            if (config.backgroundType === 'gradient') {
                                backgroundStyle = `linear-gradient(${config.gradientAngle || 145}deg, ${config.gradientColor1 || '#ffffff'}, ${config.gradientColor2 || '#ffffff'})`;
                            } else if (config.backgroundOpacity < 1) {
                                const bgColor = config.backgroundColor || '#ffffff';
                                const r = parseInt(bgColor.slice(1, 3), 16);
                                const g = parseInt(bgColor.slice(3, 5), 16);
                                const b = parseInt(bgColor.slice(5, 7), 16);
                                backgroundStyle = `rgba(${r}, ${g}, ${b}, ${config.backgroundOpacity})`;
                            }
                            
                            return `<div class="custom-bubble-container" style="position: relative; padding: 8px 12px; border: ${config.borderWidth}px solid ${config.borderColor}; border-radius: ${config.borderRadius}px; background: ${backgroundStyle};">
    <span class="bubble-text" style="position: relative; z-index: 10; color: ${config.textColor}; font-family: '${config.fontFamily}';">{{BUBBLE_TEXT}}</span>
    
</div>`;
                        };
                        
                        selfConfig = {
                            ...DEFAULT_THEME_CONFIG.self,
                            html: generateHtmlTemplate(DEFAULT_THEME_CONFIG.self),
                            css: '/* CSSå·²å†…è”åˆ°HTMLä¸­ */',
                            createdAt: new Date().toISOString()
                        };
                        
                        kareConfig = {
                            ...DEFAULT_THEME_CONFIG.kare,
                            html: generateHtmlTemplate(DEFAULT_THEME_CONFIG.kare),
                            css: '/* CSSå·²å†…è”åˆ°HTMLä¸­ */',
                            createdAt: new Date().toISOString()
                        };
                    } else {
                        // è‡ªå®šä¹‰ä¸»é¢˜ï¼šå…ˆæ‰§è¡Œå¸¸è§„ä¿å­˜
                        const result = await saveCurrentConfiguration();
                        selfConfig = result.selfConfig;
                        kareConfig = result.kareConfig;
                    }
                    
                    // 2. å†™å…¥ä¸»åº”ç”¨ä½¿ç”¨çš„themeConfigä½ç½®
                    console.log('å†™å…¥ä¸»åº”ç”¨ä½¿ç”¨çš„é…ç½®ä½ç½®...');
                    await saveBubbleStyleConfig(selfConfig, 'bubbleStyleSelf');
                    await saveBubbleStyleConfig(kareConfig, 'bubbleStyle');
                    
                    // 3. ç¡®ä¿ä¸»åº”ç”¨èƒ½è¯»å–åˆ°æœ€æ–°é…ç½®ï¼ˆç›´æ¥æ›´æ–°themeConfigè¡¨ï¼‰
                    try {
                        const transaction = db.transaction(['themeConfig'], 'readwrite');
                        const store = transaction.objectStore('themeConfig');
                        
                        // ä¿å­˜ä¸ºä¸»åº”ç”¨ç›´æ¥è¯»å–çš„é”®å
                        await new Promise((resolve, reject) => {
                            const request1 = store.put({ type: 'bubbleStyleSelf', ...selfConfig, updatedAt: new Date().toISOString() });
                            request1.onsuccess = () => resolve();
                            request1.onerror = () => reject(request1.error);
                        });
                        
                        await new Promise((resolve, reject) => {
                            const request2 = store.put({ type: 'bubbleStyle', ...kareConfig, updatedAt: new Date().toISOString() });
                            request2.onsuccess = () => resolve();
                            request2.onerror = () => reject(request2.error);
                        });
                        
                        console.log('ä¸»åº”ç”¨é…ç½®å·²æ›´æ–°');
                    } catch (error) {
                        console.warn('æ›´æ–°ä¸»åº”ç”¨é…ç½®å¤±è´¥ï¼Œä½†ä¸å½±å“åŸºæœ¬ä¿å­˜åŠŸèƒ½:', error);
                    }
                    
                    // 4. å‘é€é…ç½®ç»™ä¸»åº”ç”¨ï¼ˆpostMessageï¼‰- å‘é€ä¸¤ä¸ªç‹¬ç«‹çš„æ¶ˆæ¯
                    console.log('å‘é€æ°”æ³¡æ ·å¼ç»™ä¸»åº”ç”¨...');
                    
                    // å‘é€"æˆ‘çš„"æ°”æ³¡æ ·å¼
                    window.parent.postMessage({
                        type: 'apply-bubble-style',
                        payload: selfConfig,
                        bubbleType: 'self'
                    }, '*');
                    
                    // å‘é€"å¯¹æ–¹"æ°”æ³¡æ ·å¼  
                    window.parent.postMessage({
                        type: 'apply-bubble-style',
                        payload: kareConfig,
                        bubbleType: 'kare'
                    }, '*');
                    
                    console.log('å·²å‘é€åŒæ–¹æ°”æ³¡æ ·å¼é…ç½®ç»™ä¸»åº”ç”¨');
                    
                    showToast('å·²ä¿å­˜åŒæ–¹æ°”æ³¡æ ·å¼å¹¶åº”ç”¨åˆ°èŠå¤©ç•Œé¢ï¼', 'success');
                    const originalText = controls.generateCodeBtn.textContent;
                    controls.generateCodeBtn.textContent = 'âœ… å·²åº”ç”¨!';
                    setTimeout(() => {
                        controls.generateCodeBtn.textContent = originalText;
                    }, 2000);
                
                } catch (error) {
                    console.error('ä¿å­˜å¹¶åº”ç”¨å¤±è´¥:', error);
                    showToast('ä¿å­˜å¹¶åº”ç”¨å¤±è´¥: ' + error.message, 'error');
                }
            });
            
            // ä¿å­˜æ°”æ³¡æ ·å¼é…ç½®åˆ°IndexedDB
            async function saveBubbleStyleConfig(styleConfig, styleKey = 'bubbleStyle') {

                // 7. ç»™ç”¨æˆ·ä¸€ä¸ªåé¦ˆ
                showToast('å·²ä¿å­˜åŒæ–¹æ°”æ³¡æ ·å¼å¹¶åº”ç”¨åˆ°èŠå¤©ç•Œé¢ï¼');
                const originalText = controls.generateCodeBtn.textContent;
                controls.generateCodeBtn.textContent = 'âœ… å·²åº”ç”¨!';
                setTimeout(() => {
                    controls.generateCodeBtn.textContent = originalText;
                }, 2000);
            };


            // ä¿å­˜å®Œæ•´çš„æ°”æ³¡æ ·å¼é…ç½®
            async function saveBubbleStyleConfig(styleConfig, styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡ä¿å­˜é…ç½®');
                        return;
                    }
                    
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // å°† enabled å±æ€§æ·»åŠ åˆ° styleConfig æœ¬èº«
                    const configData = {
                        type: styleKey,
                        ...styleConfig, // å±•å¼€æ‰€æœ‰æ ·å¼é…ç½®åˆ°é¡¶å±‚
                        enabled: true,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(configData);
                    
                    transaction.oncomplete = () => {
                        console.log(`${styleKey}é…ç½®ä¿å­˜æˆåŠŸ`);
                    };
                    
                    transaction.onerror = () => {
                        console.error(`${styleKey}é…ç½®ä¿å­˜å¤±è´¥:`, transaction.error);
                    };
                } catch (e) {
                    console.error(`æ— æ³•ä¿å­˜${styleKey}é…ç½®:`, e);
                }
            }

  
            // é‡ç½®æ‰€æœ‰æ§ä»¶åˆ°é»˜è®¤å€¼
            function resetControlsToDefault() {
                // é‡ç½®åŸºç¡€æ ·å¼æ§ä»¶
                controls.bgColor.value = '#3b82f6';
                controls.textColor.value = '#ffffff';
                controls.borderRadius.value = 18;
                controls.borderWidth.value = 0;
                controls.borderColor.value = '#e2e8f0';
                controls.bgOpacity.value = 1;
                controls.borderOpacity.value = 1;
                
                // é‡ç½®æ¸å˜ç›¸å…³
                controls.bgType.value = 'solid';
                controls.gradientType.value = 'linear';
                controls.gradientColor1.value = '#3b82f6';
                controls.gradientColor2.value = '#1d4ed8';
                controls.gradientAngle.value = 45;
                
                // é‡ç½®æ–‡æœ¬å†…å®¹ä¸ºå½“å‰æ°”æ³¡ç±»å‹çš„é»˜è®¤å€¼
                const defaultText = currentBubbleType === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                controls.bubbleText.value = defaultText;
                
                // åŒæ—¶æ›´æ–°é¢„è§ˆæ˜¾ç¤º
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                currentTextContent.textContent = defaultText;
                
                // æ›´æ–°æ˜¾ç¤ºå€¼
                updateValueDisplays();
                
                // é‡æ–°åº”ç”¨æ ·å¼åˆ°é¢„è§ˆæ°”æ³¡
                updateBubblePreview();
                
                console.log('æ‰€æœ‰æ§ä»¶å·²é‡ç½®åˆ°é»˜è®¤å€¼');
            }

            // åŠ è½½å®Œæ•´çš„æ°”æ³¡æ ·å¼é…ç½®
            async function loadBubbleStyleConfig(styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡åŠ è½½é…ç½®');
                        return null;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get(styleKey);
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result) {
                                console.log(`${styleKey}é…ç½®åŠ è½½æˆåŠŸ`);
                                // ç§»é™¤ type å’Œç³»ç»Ÿå­—æ®µï¼Œè¿”å›æ ·å¼é…ç½®
                                const { type, lastModified, ...styleConfig } = result;
                                resolve(styleConfig);
                            } else {
                                console.log(`æœªæ‰¾åˆ°å·²ä¿å­˜çš„${styleKey}é…ç½®`);
                                resolve(null);
                            }
                        };
                        
                        request.onerror = () => {
                            console.error(`åŠ è½½${styleKey}é…ç½®å¤±è´¥:`, request.error);
                            resolve(null);
                        };
                    });
                } catch (e) {
                    console.error(`æ— æ³•åŠ è½½${styleKey}é…ç½®:`, e);
                    return null;
                }
            }

            // åº”ç”¨ä¿å­˜çš„é…ç½®åˆ°ç•Œé¢
            async function applyBubbleStyleConfig(config) {
                if (!config) return;
                
                try {
                    // åº”ç”¨åŸºç¡€æ ·å¼ - ä½¿ç”¨é¢œè‰²è½¬æ¢ç¡®ä¿æ ¼å¼æ­£ç¡®
                    controls.borderWidth.value = config.borderWidth || 1;
                    controls.borderColor.value = extractRgbColor(config.borderColor) || '#4f46e5';
                    controls.borderRadius.value = config.borderRadius || 12;
                    controls.textColor.value = extractRgbColor(config.textColor) || '#333333';
                    controls.fontFamily.value = config.fontFamily || 'Inter';
                    
                    // åº”ç”¨èƒŒæ™¯æ ·å¼ - ä½¿ç”¨é¢œè‰²è½¬æ¢ç¡®ä¿æ ¼å¼æ­£ç¡®
                    currentBgType = config.backgroundType || 'solid';
                    controls.bgColor.value = extractRgbColor(config.backgroundColor) || '#ffffff';
                    controls.bgOpacity.value = config.backgroundOpacity || 1;
                    controls.gradientColor1.value = extractRgbColor(config.gradientColor1) || '#a5b4fc';
                    controls.gradientColor2.value = extractRgbColor(config.gradientColor2) || '#e0e7ff';
                    controls.gradientAngle.value = config.gradientAngle || 145;
                    
                    // åˆ‡æ¢èƒŒæ™¯ç±»å‹
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.click();
                    } else {
                        controls.bgTypeSolid.click();
                    }
                    
                    // æ–‡æœ¬å†…å®¹å§‹ç»ˆä½¿ç”¨é»˜è®¤å€¼ï¼Œä¸ä»é…ç½®ä¸­åº”ç”¨
                    const defaultText = currentBubbleType === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                    currentTextContent.textContent = defaultText;
                    
                    // æ¢å¤è´´å›¾ï¼ˆä¸åœ¨è¿™é‡Œå¤„ç†ï¼Œåœ¨åˆå§‹åŒ–å‡½æ•°ä¸­å¤„ç†ï¼‰
                    // if (config.stickers && config.stickers.length > 0) {
                    //     await restoreStickers(config.stickers, currentBubbleType);
                    // }
                    
                    // æ›´æ–°æ ·å¼
                    updateBubbleStyle();
                    
                    console.log('æ°”æ³¡æ ·å¼é…ç½®å·²åº”ç”¨åˆ°ç•Œé¢');
                } catch (error) {
                    console.error('åº”ç”¨æ°”æ³¡æ ·å¼é…ç½®å¤±è´¥:', error);
                }
            }

            // æ¢å¤è´´å›¾
            async function restoreStickers(stickerConfigs, targetBubbleType = 'kare') {
                // æ¸…é™¤å¯¹åº”æ°”æ³¡çš„ç°æœ‰è´´å›¾
                const targetBubble = targetBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                targetBubble.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                
                for (const stickerConfig of stickerConfigs) {
                    const stickerData = stickerLibrary.find(s => s.id === stickerConfig.id);
                    if (!stickerData) {
                        console.warn('æ‰¾ä¸åˆ°è´´å›¾æ•°æ®:', stickerConfig.id);
                        continue;
                    }
                    
                    // åˆ›å»ºè´´å›¾å…ƒç´ 
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = stickerConfig.zIndex;
                    wrapper.style.left = stickerConfig.left + 'px';
                    wrapper.style.top = stickerConfig.top + 'px';
                    wrapper.style.width = stickerConfig.width + 'px';
                    wrapper.style.height = stickerConfig.height + 'px';
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // è·å–å›¾ç‰‡URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (imageUrl) {
                        newSticker.src = imageUrl;
                    }
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    targetBubble.appendChild(wrapper);
                    
                    makePlacedStickerInteractive(wrapper);
                }
                
                // æ¢å¤è´´çº¸åæ›´æ–°äº¤äº’çŠ¶æ€
                updateStickersInteractionState();
            }

            // å¼‚æ­¥åˆå§‹åŒ–
            async function initializeApp() {
                await initStorageSystem();
                await loadStickerLibraryFromStorage();
                await renderStickerLibrary();
                
                // åˆå§‹åŒ–ä¸»é¢˜ç®¡ç†
                await loadAvailableThemes();
                
                // æ£€æµ‹ç”¨æˆ·å½“å‰ä½¿ç”¨çš„ä¸»é¢˜å¹¶è‡ªåŠ¨åˆ‡æ¢
                const activeTheme = await detectCurrentActiveTheme();
                console.log(`æ£€æµ‹åˆ°ç”¨æˆ·å½“å‰ä½¿ç”¨çš„ä¸»é¢˜: ${activeTheme}`);
                
                // è‡ªåŠ¨åˆ‡æ¢åˆ°æ£€æµ‹åˆ°çš„ä¸»é¢˜
                await loadTheme(activeTheme);
                updateThemeSelector();
                
                console.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆï¼Œå·²åˆ‡æ¢åˆ°ç”¨æˆ·å½“å‰ä¸»é¢˜');

                const savedSelfConfig = await loadBubbleStyleConfig('bubbleStyleSelf');
                const savedKareConfig = await loadBubbleStyleConfig('bubbleStyle');
                
                if (savedSelfConfig) {
                    // åˆ‡æ¢åˆ°è‡ªå·±æ¨¡å¼å¹¶åº”ç”¨é…ç½®
                    currentBubbleType = 'self';
                    await applyBubbleStyleConfig(savedSelfConfig);
                    
                    // æ¢å¤è‡ªå·±çš„è´´å›¾
                    if (savedSelfConfig.stickers && savedSelfConfig.stickers.length > 0) {
                        await restoreStickers(savedSelfConfig.stickers, 'self');
                    }
                }
                
                if (savedKareConfig) {
                    // åˆ‡æ¢åˆ°åˆ«äººæ¨¡å¼å¹¶åº”ç”¨é…ç½®
                    currentBubbleType = 'kare';
                    await applyBubbleStyleConfig(savedKareConfig);
                    
                    // æ¢å¤åˆ«äººçš„è´´å›¾
                    if (savedKareConfig.stickers && savedKareConfig.stickers.length > 0) {
                        await restoreStickers(savedKareConfig.stickers, 'kare');
                    }
                }
                
                // é»˜è®¤åˆ‡æ¢åˆ°è‡ªå·±çš„æ°”æ³¡ç¼–è¾‘æ¨¡å¼
                switchBubbleType('self');
                
                // å¦‚æœæ²¡æœ‰ä¿å­˜çš„é…ç½®ï¼Œåº”ç”¨é»˜è®¤æ ·å¼
                if (!savedSelfConfig && !savedKareConfig) {
                    updateBubbleStyle();
                }
            }
            // ==================== å¤šä¸»é¢˜ç®¡ç†åŠŸèƒ½ ====================
            
            let currentThemeName = 'default';
            
            // å›ºå®šçš„é»˜è®¤ä¸»é¢˜é…ç½®ï¼ˆä¸å¯ä¿®æ”¹ï¼‰
            const DEFAULT_THEME_CONFIG = {
                self: {
                    borderWidth: 1,
                    borderColor: '#ffffff',
                    borderRadius: 12,
                    backgroundColor: '#33f28c',
                    backgroundOpacity: 1,
                    backgroundType: 'solid',
                    gradientColor1: '#33f28c',
                    gradientColor2: '#33f28c',
                    gradientAngle: 145,
                    textColor: '#000000',
                    fontFamily: 'Inter',
                    stickers: [],
                    enabled: true
                },
                kare: {
                    borderWidth: 1,
                    borderColor: '#ffffff',
                    borderRadius: 12,
                    backgroundColor: '#ffffff',
                    backgroundOpacity: 1,
                    backgroundType: 'solid',
                    gradientColor1: '#a5b4fc',
                    gradientColor2: '#e0e7ff',
                    gradientAngle: 145,
                    textColor: '#000000',
                    fontFamily: 'Inter',
                    stickers: [],
                    enabled: true
                }
            };
            
            // UIçŠ¶æ€ç¼“å­˜ - ä¿å­˜åŒæ–¹æ°”æ³¡çš„å½“å‰ç¼–è¾‘çŠ¶æ€
            let uiStateCache = {
                self: null,
                kare: null
            };
            
            // ä»UIæ§ä»¶è¯»å–å½“å‰çŠ¶æ€
            function captureCurrentUIState() {
                const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                
                return {
                    borderWidth: controls.borderWidth.value,
                    borderColor: controls.borderColor.value,
                    borderRadius: controls.borderRadius.value,
                    textColor: controls.textColor.value,
                    fontFamily: controls.fontFamily.value,
                    backgroundColor: controls.bgColor.value,
                    backgroundOpacity: controls.bgOpacity.value,
                    backgroundType: currentBgType,
                    gradientColor1: controls.gradientColor1.value,
                    gradientColor2: controls.gradientColor2.value,
                    gradientAngle: controls.gradientAngle.value,
                    // æ·»åŠ è´´çº¸ä¿¡æ¯æ”¶é›†
                    stickers: Array.from(targetBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => {
                        const stickerId = wrapper.dataset.id;
                        const stickerInfo = stickerLibrary.find(s => s.id === stickerId);
                        return {
                            id: stickerId,
                            fileId: stickerInfo?.fileId || '',
                            left: parseFloat(wrapper.style.left) || 0,
                            top: parseFloat(wrapper.style.top) || 0,
                            width: wrapper.offsetWidth,
                            height: wrapper.offsetHeight,
                            zIndex: wrapper.style.zIndex || 1
                        };
                    })
                };
            }
            
            // å°†çŠ¶æ€åº”ç”¨åˆ°UIæ§ä»¶
            function applyUIState(state) {
                if (!state) return;
                
                controls.borderWidth.value = state.borderWidth || 1;
                controls.borderColor.value = state.borderColor || '#4f46e5';
                controls.borderRadius.value = state.borderRadius || 12;
                controls.textColor.value = state.textColor || '#333333';
                controls.fontFamily.value = state.fontFamily || 'Inter';
                controls.bgColor.value = state.backgroundColor || '#ffffff';
                controls.bgOpacity.value = state.backgroundOpacity || 1;
                controls.gradientColor1.value = state.gradientColor1 || '#a5b4fc';
                controls.gradientColor2.value = state.gradientColor2 || '#e0e7ff';
                controls.gradientAngle.value = state.gradientAngle || 145;
                
                // æ›´æ–°èƒŒæ™¯ç±»å‹
                currentBgType = state.backgroundType || 'solid';
                if (currentBgType === 'gradient') {
                    controls.bgTypeGradient.checked = true;
                    controls.bgTypeSolid.checked = false;
                    controls.solidBgControls.classList.add('hidden');
                    controls.gradientBgControls.classList.remove('hidden');
                    controls.bgTypeGradient.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                    controls.bgTypeSolid.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                } else {
                    controls.bgTypeSolid.checked = true;
                    controls.bgTypeGradient.checked = false;
                    controls.solidBgControls.classList.remove('hidden');
                    controls.gradientBgControls.classList.add('hidden');
                    controls.bgTypeSolid.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                    controls.bgTypeGradient.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                }
                
                // æ›´æ–°å€¼æ˜¾ç¤ºæ ‡ç­¾
                controls.borderWidthValue.textContent = `${controls.borderWidth.value}px`;
                controls.borderRadiusValue.textContent = `${controls.borderRadius.value}px`;
                controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
                
                // æ›´æ–°æ–‡æœ¬å†…å®¹
                const defaultText = currentBubbleType === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                controls.bubbleText.value = defaultText;
                const targetTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentKare;
                targetTextContent.textContent = defaultText;
                
                // æ¢å¤è´´çº¸çŠ¶æ€
                if (state.stickers && state.stickers.length > 0) {
                    const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleKare;
                    
                    // æ¸…é™¤å½“å‰çš„æ‰€æœ‰è´´çº¸
                    targetBubble.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                        wrapper.remove();
                    });
                    
                    // æ¢å¤ä¿å­˜çš„è´´çº¸
                    state.stickers.forEach(async (stickerData) => {
                        if (stickerData.fileId && fileStorageManager) {
                            try {
                                const imageUrl = await fileStorageManager.createFileURL(stickerData.fileId);
                                
                                const stickerWrapper = document.createElement('div');
                                stickerWrapper.className = 'sticker-wrapper';
                                stickerWrapper.dataset.id = stickerData.id;
                                stickerWrapper.style.position = 'absolute';
                                stickerWrapper.style.left = `${stickerData.left}px`;
                                stickerWrapper.style.top = `${stickerData.top}px`;
                                stickerWrapper.style.width = `${stickerData.width}px`;
                                stickerWrapper.style.height = `${stickerData.height}px`;
                                stickerWrapper.style.zIndex = stickerData.zIndex || 1;
                                stickerWrapper.style.cursor = 'move';
                                
                                const img = document.createElement('img');
                                img.src = imageUrl;
                                img.className = 'sticker-image';
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'contain';
                                img.style.userSelect = 'none';
                                img.style.pointerEvents = 'none';
                                
                                stickerWrapper.appendChild(img);
                                targetBubble.appendChild(stickerWrapper);
                                
                                // ä½¿è´´çº¸å¯æ‹–æ‹½
                                makeStickerDraggable(stickerWrapper);
                                
                            } catch (error) {
                                console.warn('æ¢å¤è´´çº¸å¤±è´¥:', error, stickerData);
                            }
                        }
                    });
                }
                
                console.log(`å·²åº”ç”¨UIçŠ¶æ€åˆ°${currentBubbleType}: backgroundType=${currentBgType}, stickers=${state.stickers?.length || 0}`);
            }
            let availableThemes = ['default'];

            // åŠ è½½æ‰€æœ‰å¯ç”¨ä¸»é¢˜
            async function loadAvailableThemes() {
                try {
                    if (!db) return;
                    
                    const transaction = db.transaction(['themeConfig'], 'readonly');
                    const store = transaction.objectStore('themeConfig');
                    
                    return new Promise((resolve) => {
                        const themes = ['default']; // é»˜è®¤ä¸»é¢˜å§‹ç»ˆå­˜åœ¨
                        const request = store.openCursor();
                        
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                const key = cursor.key;
                                // æŸ¥æ‰¾è‡ªå®šä¹‰ä¸»é¢˜ï¼ˆä»¥theme_å¼€å¤´çš„é”®ï¼‰
                                if (typeof key === 'string' && key.startsWith('theme_')) {
                                    const themeName = key.substring(6); // ç§»é™¤'theme_'å‰ç¼€
                                    themes.push(themeName);
                                }
                                cursor.continue();
                            } else {
                                availableThemes = themes;
                                resolve(themes);
                            }
                        };
                        
                        request.onerror = () => {
                            resolve(['default']);
                        };
                    });
                } catch (e) {
                    console.error('åŠ è½½ä¸»é¢˜åˆ—è¡¨å¤±è´¥:', e);
                    return ['default'];
                }
            }

            // æ›´æ–°ä¸»é¢˜é€‰æ‹©ä¸‹æ‹‰èœå•
            function updateThemeSelector() {
                controls.themeSelect.innerHTML = '';
                
                availableThemes.forEach(themeName => {
                    const option = document.createElement('option');
                    option.value = themeName;
                    option.textContent = themeName === 'default' ? 'é»˜è®¤ä¸»é¢˜' : themeName;
                    if (themeName === currentThemeName) {
                        option.selected = true;
                    }
                    controls.themeSelect.appendChild(option);
                });
                
                // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
                controls.deleteThemeBtn.disabled = currentThemeName === 'default';
                controls.deleteThemeBtn.style.opacity = currentThemeName === 'default' ? '0.3' : '1';
                
                controls.renameThemeBtn.disabled = currentThemeName === 'default';
                controls.renameThemeBtn.style.opacity = currentThemeName === 'default' ? '0.3' : '1';
            }

            // åŸºäºé»˜è®¤ä¸»é¢˜åˆ›å»ºæ–°ä¸»é¢˜
            async function createNewTheme() {
                const themeName = prompt('è¯·è¾“å…¥æ–°ä¸»é¢˜çš„åç§°:');
                if (!themeName || themeName.trim() === '') {
                    return;
                }
                
                const cleanThemeName = themeName.trim();
                if (cleanThemeName === 'default') {
                    showToast('ä¸èƒ½ä½¿ç”¨"default"ä½œä¸ºä¸»é¢˜åç§°', 'error');
                    return;
                }
                
                if (availableThemes.includes(cleanThemeName)) {
                    if (!confirm(`ä¸»é¢˜"${cleanThemeName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) {
                        return;
                    }
                }
                
                try {
                    // åŸºäºé»˜è®¤ä¸»é¢˜é…ç½®åˆ›å»ºæ–°ä¸»é¢˜
                    const themeData = {
                        type: `theme_${cleanThemeName}`,
                        name: cleanThemeName,
                        createdAt: new Date().toISOString(),
                        bubbleStyles: {
                            self: { ...DEFAULT_THEME_CONFIG.self },
                            kare: { ...DEFAULT_THEME_CONFIG.kare }
                        },
                        stickerLibrary: []  // æ–°ä¸»é¢˜ä¸åŒ…å«è´´çº¸
                    };
                    
                    // ä¿å­˜åˆ°æ•°æ®åº“
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.put(themeData);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // æ›´æ–°ä¸»é¢˜åˆ—è¡¨å’Œå½“å‰ä¸»é¢˜
                    if (!availableThemes.includes(cleanThemeName)) {
                        availableThemes.push(cleanThemeName);
                    }
                    currentThemeName = cleanThemeName;
                    updateThemeSelector();
                    
                    // è‡ªåŠ¨åˆ‡æ¢åˆ°æ–°åˆ›å»ºçš„ä¸»é¢˜
                    await loadTheme(cleanThemeName);
                    
                    showToast(`å·²åŸºäºé»˜è®¤ä¸»é¢˜åˆ›å»º"${cleanThemeName}"ï¼`, 'success');
                    
                } catch (e) {
                    console.error('åˆ›å»ºä¸»é¢˜å¤±è´¥:', e);
                    showToast('åˆ›å»ºä¸»é¢˜å¤±è´¥: ' + e.message, 'error');
                }
            }

            
            // æ£€æµ‹ç”¨æˆ·å½“å‰åº”ç”¨çš„ä¸»é¢˜
            async function detectCurrentActiveTheme() {
                try {
                    // ä»themeConfigè¯»å–å½“å‰ç”Ÿæ•ˆçš„é…ç½®
                    const currentSelfConfig = await loadBubbleStyleConfig('bubbleStyleSelf');
                    const currentKareConfig = await loadBubbleStyleConfig('bubbleStyle');
                    
                    if (!currentSelfConfig && !currentKareConfig) {
                        // å¦‚æœæ²¡æœ‰é…ç½®ï¼Œè¿”å›é»˜è®¤ä¸»é¢˜
                        return 'default';
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦åŒ¹é…é»˜è®¤ä¸»é¢˜
                    if (configMatches(currentSelfConfig, DEFAULT_THEME_CONFIG.self) && 
                        configMatches(currentKareConfig, DEFAULT_THEME_CONFIG.kare)) {
                        return 'default';
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦åŒ¹é…æŸä¸ªè‡ªå®šä¹‰ä¸»é¢˜
                    for (const themeName of availableThemes) {
                        if (themeName === 'default') continue;
                        
                        const themeData = await loadThemeData(themeName);
                        if (themeData && themeData.bubbleStyles) {
                            if (configMatches(currentSelfConfig, themeData.bubbleStyles.self) && 
                                configMatches(currentKareConfig, themeData.bubbleStyles.kare)) {
                                return themeName;
                            }
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰åŒ¹é…çš„ä¸»é¢˜ï¼Œè¿”å›é»˜è®¤ä¸»é¢˜
                    return 'default';
                } catch (error) {
                    console.warn('æ£€æµ‹å½“å‰ä¸»é¢˜å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ä¸»é¢˜:', error);
                    return 'default';
                }
            }
            
            // é…ç½®åŒ¹é…æ£€æŸ¥ï¼ˆç®€åŒ–æ¯”è¾ƒä¸»è¦å­—æ®µï¼‰
            function configMatches(config1, config2) {
                if (!config1 || !config2) return false;
                
                const keyFields = ['borderWidth', 'borderColor', 'backgroundColor', 'backgroundType', 'textColor'];
                return keyFields.every(field => config1[field] === config2[field]);
            }
            
            // åŠ è½½ä¸»é¢˜æ•°æ®
            async function loadThemeData(themeName) {
                try {
                    const transaction = db.transaction(['themeConfig'], 'readonly');
                    const store = transaction.objectStore('themeConfig');
                    
                    return await new Promise((resolve, reject) => {
                        const request = store.get(`theme_${themeName}`);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error(`åŠ è½½ä¸»é¢˜æ•°æ®å¤±è´¥: ${themeName}`, error);
                    return null;
                }
            }
            
            // ç›´æ¥åº”ç”¨é…ç½®åˆ°UIæ§ä»¶ï¼ˆç”¨äºé»˜è®¤ä¸»é¢˜æ˜¾ç¤ºï¼‰
            async function applyConfigToUI(bubbleType, config) {
                const originalBubbleType = currentBubbleType;
                
                // ä¸´æ—¶åˆ‡æ¢åˆ°æŒ‡å®šæ°”æ³¡ç±»å‹
                currentBubbleType = bubbleType;
                
                // åº”ç”¨é…ç½®åˆ°UIæ§ä»¶
                if (config) {
                    controls.borderWidth.value = config.borderWidth || 1;
                    controls.borderColor.value = config.borderColor || '#4f46e5';
                    controls.borderRadius.value = config.borderRadius || 12;
                    controls.textColor.value = config.textColor || '#333333';
                    controls.fontFamily.value = config.fontFamily || 'Inter';
                    
                    controls.bgColor.value = config.backgroundColor || '#ffffff';
                    controls.bgOpacity.value = config.backgroundOpacity || 1;
                    controls.gradientColor1.value = config.gradientColor1 || '#a5b4fc';
                    controls.gradientColor2.value = config.gradientColor2 || '#e0e7ff';
                    controls.gradientAngle.value = config.gradientAngle || 145;
                    
                    // è®¾ç½®èƒŒæ™¯ç±»å‹
                    currentBgType = config.backgroundType || 'solid';
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.checked = true;
                        controls.bgTypeSolid.checked = false;
                        controls.solidBgControls.classList.add('hidden');
                        controls.gradientBgControls.classList.remove('hidden');
                        // æ›´æ–°æŒ‰é’®æ ·å¼
                        controls.bgTypeGradient.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeSolid.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    } else {
                        controls.bgTypeSolid.checked = true;
                        controls.bgTypeGradient.checked = false;
                        controls.solidBgControls.classList.remove('hidden');
                        controls.gradientBgControls.classList.add('hidden');
                        // æ›´æ–°æŒ‰é’®æ ·å¼
                        controls.bgTypeSolid.className = 'bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold';
                        controls.bgTypeGradient.className = 'bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold';
                    }
                    
                    // æ›´æ–°å€¼æ˜¾ç¤ºæ ‡ç­¾
                    controls.borderWidthValue.textContent = `${config.borderWidth || 1}px`;
                    controls.borderRadiusValue.textContent = `${config.borderRadius || 12}px`;
                    controls.bgOpacityValue.textContent = `${Math.round((config.backgroundOpacity || 1) * 100)}%`;
                    controls.gradientAngleValue.textContent = `${config.gradientAngle || 145}deg`;
                    
                    // è®¾ç½®æ–‡æœ¬å†…å®¹
                    const defaultText = bubbleType === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    
                    // æ›´æ–°æ°”æ³¡æ ·å¼
                    updateBubbleStyle();
                }
                
                // æ¢å¤åŸå§‹æ°”æ³¡ç±»å‹
                currentBubbleType = originalBubbleType;
            }
            
            // æ›´æ–°ä¸»é¢˜UIçŠ¶æ€
            function updateThemeUIState() {
                const isDefaultTheme = currentThemeName === 'default';
                
                if (isDefaultTheme) {
                    // æ˜¾ç¤ºé»˜è®¤ä¸»é¢˜æç¤º
                    controls.defaultThemeNotice.classList.remove('hidden');
                    
                    // ç¦ç”¨æ‰€æœ‰ç¼–è¾‘æ§ä»¶
                    const editControls = [
                        controls.borderWidth, controls.borderColor, controls.borderRadius,
                        controls.textColor, controls.fontFamily, controls.bgColor, controls.bgOpacity,
                        controls.gradientColor1, controls.gradientColor2, controls.gradientAngle,
                        controls.bgTypeSolid, controls.bgTypeGradient, controls.bubbleText
                    ];
                    
                    editControls.forEach(control => {
                        if (control) {
                            control.disabled = true;
                            control.style.opacity = '0.5';
                        }
                    });
                    
                    // ç¦ç”¨ä¿å­˜æŒ‰é’®
                    controls.saveOnlyBtn.disabled = true;
                    controls.generateCodeBtn.disabled = true;
                    controls.saveOnlyBtn.style.opacity = '0.5';
                    controls.generateCodeBtn.style.opacity = '0.5';
                } else {
                    // éšè—é»˜è®¤ä¸»é¢˜æç¤º
                    controls.defaultThemeNotice.classList.add('hidden');
                    
                    // å¯ç”¨æ‰€æœ‰ç¼–è¾‘æ§ä»¶
                    const editControls = [
                        controls.borderWidth, controls.borderColor, controls.borderRadius,
                        controls.textColor, controls.fontFamily, controls.bgColor, controls.bgOpacity,
                        controls.gradientColor1, controls.gradientColor2, controls.gradientAngle,
                        controls.bgTypeSolid, controls.bgTypeGradient, controls.bubbleText
                    ];
                    
                    editControls.forEach(control => {
                        if (control) {
                            control.disabled = false;
                            control.style.opacity = '1';
                        }
                    });
                    
                    // å¯ç”¨ä¿å­˜æŒ‰é’®
                    controls.saveOnlyBtn.disabled = false;
                    controls.generateCodeBtn.disabled = false;
                    controls.saveOnlyBtn.style.opacity = '1';
                    controls.generateCodeBtn.style.opacity = '1';
                }
                
                console.log(`ä¸»é¢˜UIçŠ¶æ€å·²æ›´æ–°: ${currentThemeName} (é”å®š: ${isDefaultTheme})`);
            }
            // åŠ è½½æŒ‡å®šä¸»é¢˜
            async function loadTheme(themeName) {
                try {
                    console.log(`å¼€å§‹åŠ è½½ä¸»é¢˜: ${themeName}`);
                    
                    if (themeName === 'default') {
                        // åŠ è½½å›ºå®šçš„é»˜è®¤ä¸»é¢˜é…ç½®
                        currentThemeName = 'default';
                        
                        // ä½¿ç”¨å›ºå®šçš„é»˜è®¤é…ç½®ï¼ˆä¸ä»æ•°æ®åº“è¯»å–ï¼‰
                        const defaultSelfConfig = DEFAULT_THEME_CONFIG.self;
                        const defaultKareConfig = DEFAULT_THEME_CONFIG.kare;
                        
                        // æ¸…ç©ºUIç¼“å­˜
                        uiStateCache = { self: null, kare: null };
                        
                        // ä¸´æ—¶ä¿å­˜å½“å‰æ°”æ³¡ç±»å‹
                        const originalBubbleType = currentBubbleType;
                        
                        // å…ˆåº”ç”¨selfé…ç½®åˆ°UIå¹¶æ›´æ–°é¢„è§ˆ
                        currentBubbleType = 'self';
                        await applyConfigToUI('self', defaultSelfConfig);
                        updateBubbleStyle();
                        
                        // å†åº”ç”¨kareé…ç½®åˆ°UIå¹¶æ›´æ–°é¢„è§ˆ
                        currentBubbleType = 'kare';
                        await applyConfigToUI('kare', defaultKareConfig);
                        updateBubbleStyle();
                        
                        // æ¢å¤åŸæ¥çš„æ°”æ³¡ç±»å‹
                        currentBubbleType = originalBubbleType;
                        
                        showToast('å·²åˆ‡æ¢åˆ°é»˜è®¤ä¸»é¢˜ï¼ˆåªè¯»æ¨¡å¼ï¼‰', 'info');
                    } else {
                        // åŠ è½½è‡ªå®šä¹‰ä¸»é¢˜
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        
                        const themeData = await new Promise((resolve, reject) => {
                            const request = store.get(`theme_${themeName}`);
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        console.log('ä¸»é¢˜æ•°æ®:', JSON.stringify({
                            name: themeName,
                            hasBubbleStyles: !!themeData?.bubbleStyles,
                            selfStyle: themeData?.bubbleStyles?.self ? {
                                backgroundType: themeData.bubbleStyles.self.backgroundType,
                                gradientColor1: themeData.bubbleStyles.self.gradientColor1,
                                gradientColor2: themeData.bubbleStyles.self.gradientColor2
                            } : null,
                            kareStyle: themeData?.bubbleStyles?.kare ? {
                                backgroundType: themeData.bubbleStyles.kare.backgroundType,
                                gradientColor1: themeData.bubbleStyles.kare.gradientColor1,
                                gradientColor2: themeData.bubbleStyles.kare.gradientColor2
                            } : null
                        }, null, 2));
                        
                        if (themeData && themeData.bubbleStyles && 
                            (themeData.bubbleStyles.self || themeData.bubbleStyles.kare)) {
                            
                            // ä¸´æ—¶ä¿å­˜ä¸»é¢˜æ•°æ®åˆ°å·¥ä½œä½ç½®ï¼ˆåªä¿å­˜æœ‰æ•ˆé…ç½®ï¼‰
                            if (themeData.bubbleStyles.self && Object.keys(themeData.bubbleStyles.self).length > 0) {
                                await saveBubbleStyleConfig(themeData.bubbleStyles.self, 'bubbleStyleSelf');
                                console.log('ä¸»é¢˜selfé…ç½®å·²ä¿å­˜åˆ°å·¥ä½œåŒº');
                            }
                            if (themeData.bubbleStyles.kare && Object.keys(themeData.bubbleStyles.kare).length > 0) {
                                await saveBubbleStyleConfig(themeData.bubbleStyles.kare, 'bubbleStyle');
                                console.log('ä¸»é¢˜kareé…ç½®å·²ä¿å­˜åˆ°å·¥ä½œåŒº');
                            }
                            
                                
                            currentThemeName = themeName;
                            
                            // æ¸…ç©ºUIç¼“å­˜ï¼Œå¼ºåˆ¶é‡æ–°åŠ è½½
                            uiStateCache = { self: null, kare: null };
                            
                            // åŒæ—¶åˆå§‹åŒ–åŒæ–¹çš„UIçŠ¶æ€ç¼“å­˜
                            const tempBubbleType = currentBubbleType;
                            
                            // åŠ è½½selfé…ç½®åˆ°ç¼“å­˜
                            currentBubbleType = 'self';
                            await loadBubbleTypeSettings('self');
                            uiStateCache.self = captureCurrentUIState();
                            console.log(`ä¸»é¢˜"${themeName}"çš„selfé…ç½®å·²ç¼“å­˜`);
                            
                            // åŠ è½½kareé…ç½®åˆ°ç¼“å­˜
                            currentBubbleType = 'kare';
                            await loadBubbleTypeSettings('kare');
                            uiStateCache.kare = captureCurrentUIState();
                            console.log(`ä¸»é¢˜"${themeName}"çš„kareé…ç½®å·²ç¼“å­˜`);
                            
                            // æ¢å¤åˆ°åŸæ¥çš„è§’è‰²å¹¶åº”ç”¨çŠ¶æ€
                            currentBubbleType = tempBubbleType;
                            applyUIState(uiStateCache[currentBubbleType]);
                            updateBubbleStyle();
                            
                            console.log(`ä¸»é¢˜"${themeName}"åŠ è½½å®Œæˆï¼ŒåŒæ–¹é…ç½®å·²ç¼“å­˜`);
                            
                            showToast(`ä¸»é¢˜"${themeName}"å·²åŠ è½½`, 'success');
                        } else {
                            throw new Error('ä¸»é¢˜æ•°æ®ä¸å­˜åœ¨æˆ–æŸå');
                        }
                    }
                    
                    // æ›´æ–°ä¸»é¢˜UIçŠ¶æ€ï¼ˆé”å®š/è§£é”æ§ä»¶ï¼‰
                    updateThemeUIState();
                    updateThemeSelector();
                    
                } catch (e) {
                    console.error('åŠ è½½ä¸»é¢˜å¤±è´¥:', e);
                    showToast('åŠ è½½ä¸»é¢˜å¤±è´¥: ' + e.message, 'error');
                }
            }

            // åˆ é™¤ä¸»é¢˜
            async function deleteTheme(themeName) {
                if (themeName === 'default') {
                    showToast('ä¸èƒ½åˆ é™¤é»˜è®¤ä¸»é¢˜', 'error');
                    return;
                }
                
                if (!confirm(`ç¡®å®šè¦åˆ é™¤ä¸»é¢˜"${themeName}"å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
                    return;
                }
                
                try {
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(`theme_${themeName}`);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // æ›´æ–°ä¸»é¢˜åˆ—è¡¨
                    availableThemes = availableThemes.filter(t => t !== themeName);
                    
                    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä¸»é¢˜ï¼Œåˆ‡æ¢åˆ°é»˜è®¤ä¸»é¢˜
                    if (currentThemeName === themeName) {
                        currentThemeName = 'default';
                        await loadTheme('default');
                    }
                    
                    updateThemeSelector();
                    showToast(`ä¸»é¢˜"${themeName}"åˆ é™¤æˆåŠŸï¼`, 'success');
                    
                } catch (e) {
                    console.error('åˆ é™¤ä¸»é¢˜å¤±è´¥:', e);
                    showToast('åˆ é™¤ä¸»é¢˜å¤±è´¥: ' + e.message, 'error');
                }
            }

            // é‡å‘½åä¸»é¢˜
            async function renameTheme(oldThemeName) {
                if (oldThemeName === 'default') {
                    showToast('ä¸èƒ½é‡å‘½åé»˜è®¤ä¸»é¢˜', 'error');
                    return;
                }
                
                const newName = prompt('è¯·è¾“å…¥æ–°çš„ä¸»é¢˜åç§°:', oldThemeName);
                if (!newName || newName.trim() === '') {
                    return;
                }
                
                const cleanNewName = newName.trim();
                if (cleanNewName === oldThemeName) {
                    return;
                }
                
                if (cleanNewName === 'default') {
                    showToast('ä¸èƒ½ä½¿ç”¨"default"ä½œä¸ºä¸»é¢˜åç§°', 'error');
                    return;
                }
                
                if (availableThemes.includes(cleanNewName)) {
                    showToast(`ä¸»é¢˜åç§°"${cleanNewName}"å·²å­˜åœ¨`, 'error');
                    return;
                }
                
                try {
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // è¯»å–æ—§ä¸»é¢˜æ•°æ®
                    const oldData = await new Promise((resolve, reject) => {
                        const request = store.get(`theme_${oldThemeName}`);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (!oldData) {
                        showToast('ä¸»é¢˜æ•°æ®ä¸å­˜åœ¨', 'error');
                        return;
                    }
                    
                    // åˆ é™¤æ—§ä¸»é¢˜
                    await new Promise((resolve, reject) => {
                        const request = store.delete(`theme_${oldThemeName}`);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // åˆ›å»ºæ–°ä¸»é¢˜æ•°æ®ï¼ˆä¿æŒåŸæœ‰çš„æ•°æ®å’ŒIDï¼‰
                    const newData = {
                        ...oldData,
                        type: `theme_${cleanNewName}`,
                        name: cleanNewName,
                        renamedFrom: oldThemeName,
                        renamedAt: new Date().toISOString()
                    };
                    
                    // ä¿å­˜æ–°ä¸»é¢˜
                    await new Promise((resolve, reject) => {
                        const request = store.put(newData);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    // æ›´æ–°ä¸»é¢˜åˆ—è¡¨
                    const index = availableThemes.indexOf(oldThemeName);
                    if (index > -1) {
                        availableThemes[index] = cleanNewName;
                    }
                    
                    // å¦‚æœå½“å‰ä¸»é¢˜æ˜¯è¢«é‡å‘½åçš„ä¸»é¢˜ï¼Œæ›´æ–°å½“å‰ä¸»é¢˜åç§°
                    if (currentThemeName === oldThemeName) {
                        currentThemeName = cleanNewName;
                    }
                    
                    updateThemeSelector();
                    showToast(`ä¸»é¢˜å·²é‡å‘½åä¸º"${cleanNewName}"`, 'success');
                    
                } catch (e) {
                    console.error('é‡å‘½åä¸»é¢˜å¤±è´¥:', e);
                    showToast('é‡å‘½åå¤±è´¥: ' + e.message, 'error');
                }
            }

            // ==================== ä¸»é¢˜å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ ====================
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
            function hasUnsavedChanges() {
                // ç®€å•å®ç°ï¼šæ£€æŸ¥å½“å‰ç•Œé¢é…ç½®æ˜¯å¦ä¸æ•°æ®åº“ä¸­ä¿å­˜çš„é…ç½®ä¸€è‡´
                // è¿™é‡Œå¯ä»¥æ ¹æ®éœ€è¦å®ç°æ›´ç²¾ç¡®çš„æ£€æŸ¥é€»è¾‘
                return false; // æš‚æ—¶è¿”å›falseï¼Œåç»­å¯ä»¥å®Œå–„
            }

            // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
            function showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type === 'error' ? 'bg-red-500' : type === 'success' ? 'bg-green-500' : 'bg-blue-500'} text-white px-4 py-2 rounded-lg fixed top-4 right-4 z-[9999]`;
                toast.style.display = 'block';
                
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 3000);
            }

            // å¯¼å‡ºä¸»é¢˜åŠŸèƒ½
            async function exportBubbleTheme() {
                try {
                    showToast('æ­£åœ¨å¯¼å‡ºä¸»é¢˜ï¼Œè¯·ç¨å€™...', 'info');
                    
                    // 1. æ”¶é›†æ ·å¼é…ç½®
                    const bubbleStyleSelf = await loadBubbleStyleConfig('bubbleStyleSelf');
                    const bubbleStyleKare = await loadBubbleStyleConfig('bubbleStyle');
                    
                    // 2. æ”¶é›†è´´çº¸åº“æ•°æ®
                    await loadStickerLibraryFromStorage();
                    
                    // 3. åˆ›å»ºå¯¼å‡ºé…ç½®
                    const exportConfig = {
                        version: "1.0",
                        exportTime: new Date().toISOString(),
                        themeName: currentThemeName === 'default' ? 'ExportedTheme' : currentThemeName,
                        bubbleStyles: {
                            self: bubbleStyleSelf || null,
                            kare: bubbleStyleKare || null
                        },
                        stickerLibrary: stickerLibrary || []
                    };

                    // 4. åˆ›å»ºzipæ–‡ä»¶
                    const zip = new JSZip();
                    
                    // æ·»åŠ é…ç½®æ–‡ä»¶
                    zip.file('config.json', JSON.stringify(exportConfig, null, 2));
                    
                    // æ·»åŠ æ¸…å•æ–‡ä»¶
                    const manifest = {
                        version: "1.0",
                        createdAt: new Date().toISOString(),
                        totalStickers: stickerLibrary.length,
                        hasStyles: {
                            self: !!bubbleStyleSelf,
                            kare: !!bubbleStyleKare
                        }
                    };
                    zip.file('manifest.json', JSON.stringify(manifest, null, 2));
                    
                    // 5. æ·»åŠ è´´çº¸æ–‡ä»¶
                    const stickerFolder = zip.folder('stickers');
                    const stickerFileMapping = {};
                    
                    for (let i = 0; i < stickerLibrary.length; i++) {
                        const sticker = stickerLibrary[i];
                        try {
                            if (sticker.fileId && fileStorageManager) {
                                // è·å–æ–‡ä»¶è®°å½•
                                const fileRecord = await fileStorageManager.getFile(sticker.fileId);
                                if (fileRecord && fileRecord.blob) {
                                    // ç”Ÿæˆæ–‡ä»¶åï¼šä¿æŒåŸæ‰©å±•å
                                    const ext = sticker.originalName ? 
                                        sticker.originalName.split('.').pop() : 
                                        (sticker.fileType === 'image/svg+xml' ? 'svg' : 'png');
                                    const fileName = `${sticker.fileId}.${ext}`;
                                    
                                    stickerFolder.file(fileName, fileRecord.blob);
                                    stickerFileMapping[sticker.id] = fileName;
                                }
                            }
                        } catch (error) {
                            console.warn(`å¯¼å‡ºè´´çº¸ ${sticker.id} å¤±è´¥:`, error);
                        }
                    }
                    
                    // æ›´æ–°é…ç½®ä¸­çš„æ–‡ä»¶æ˜ å°„
                    exportConfig.stickerFileMapping = stickerFileMapping;
                    zip.file('config.json', JSON.stringify(exportConfig, null, 2));
                    
                    // 6. ç”Ÿæˆå¹¶ä¸‹è½½zipæ–‡ä»¶
                    const zipBlob = await zip.generateAsync({type: 'blob'});
                    const url = URL.createObjectURL(zipBlob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `bubble-theme-${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('ä¸»é¢˜å¯¼å‡ºæˆåŠŸï¼', 'success');
                    
                } catch (error) {
                    console.error('å¯¼å‡ºä¸»é¢˜å¤±è´¥:', error);
                    showToast('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
                }
            }

            // å¯¼å…¥ä¸»é¢˜åŠŸèƒ½
            async function importBubbleTheme(zipFile) {
                try {
                    showToast('æ­£åœ¨å¯¼å…¥ä¸»é¢˜ï¼Œè¯·ç¨å€™...', 'info');
                    
                    // 1. è§£æzipæ–‡ä»¶
                    const zip = await JSZip.loadAsync(zipFile);
                    
                    // 2. è¯»å–å’ŒéªŒè¯é…ç½®æ–‡ä»¶
                    const configFile = zip.file('config.json');
                    if (!configFile) {
                        throw new Error('ä¸»é¢˜åŒ…ç¼ºå°‘é…ç½®æ–‡ä»¶');
                    }
                    
                    const configText = await configFile.async('text');
                    const config = JSON.parse(configText);
                    
                    if (!config.version) {
                        throw new Error('æ— æ•ˆçš„ä¸»é¢˜åŒ…æ ¼å¼');
                    }
                    
                    // 3. è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦åº”ç”¨é…ç½®
                    const stickerCount = config.stickerLibrary?.length || 0;
                    const hasStyles = config.bubbleStyles?.self || config.bubbleStyles?.kare;
                    
                    let message = `å³å°†å¯¼å…¥åŒ…å« ${stickerCount} ä¸ªè´´çº¸`;
                    if (hasStyles) {
                        message += ' å’Œæ°”æ³¡æ ·å¼é…ç½®';
                    }
                    message += ' çš„ä¸»é¢˜åŒ…ã€‚\n\n';
                    
                    if (stickerLibrary.length > 0) {
                        message += 'æ£€æµ‹åˆ°ç°æœ‰è´´çº¸åº“ï¼Œå¦‚å‘ç°é‡åæ–‡ä»¶å°†è¯¢é—®æ‚¨çš„å¤„ç†æ–¹å¼ã€‚\n\n';
                    }
                    
                    message += 'æ˜¯å¦ç»§ç»­å¯¼å…¥ï¼Ÿ';
                    
                    if (!confirm(message)) {
                        return;
                    }
                    
                    // 4. å¯¼å…¥è´´çº¸æ–‡ä»¶
                    const newStickerLibrary = [];
                    const nameConflicts = [];
                    
                    if (config.stickerLibrary && config.stickerLibrary.length > 0) {
                        const stickerFolder = zip.folder('stickers');
                        
                        for (const stickerConfig of config.stickerLibrary) {
                            try {
                                const fileName = config.stickerFileMapping?.[stickerConfig.id];
                                if (!fileName) continue;
                                
                                const stickerFile = stickerFolder.file(fileName);
                                if (!stickerFile) continue;
                                
                                // æ£€æŸ¥æ–‡ä»¶åå†²çª
                                let finalName = stickerConfig.originalName;
                                const existingSticker = stickerLibrary.find(s => s.originalName === finalName);
                                
                                if (existingSticker) {
                                    const action = confirm(`å‘ç°é‡åæ–‡ä»¶ "${finalName}"ã€‚\n\nç‚¹å‡»"ç¡®å®š"è¦†ç›–ç°æœ‰æ–‡ä»¶\nç‚¹å‡»"å–æ¶ˆ"ä¿ç•™ä¸¤ä¸ªæ–‡ä»¶ï¼ˆæ–°æ–‡ä»¶å°†é‡å‘½åï¼‰`);
                                    
                                    if (!action) {
                                        // é‡å‘½åæ–°æ–‡ä»¶
                                        const nameParts = finalName.split('.');
                                        const ext = nameParts.pop();
                                        const baseName = nameParts.join('.');
                                        finalName = `${baseName}(1).${ext}`;
                                    } else {
                                        // åˆ é™¤ç°æœ‰æ–‡ä»¶
                                        await deleteSticker(existingSticker.id);
                                    }
                                }
                                
                                // è·å–æ–‡ä»¶æ•°æ®å¹¶å­˜å‚¨
                                const fileBlob = await stickerFile.async('blob');
                                const newStickerId = 'sticker_import_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                                
                                if (fileStorageManager) {
                                    // å­˜å‚¨åˆ°æ–‡ä»¶ç³»ç»Ÿ
                                    const storeResult = await fileStorageManager.storeFile(fileBlob, {
                                        category: 'bubble_sticker',
                                        originalName: finalName
                                    });
                                    
                                    // åˆ›å»ºæ–‡ä»¶å¼•ç”¨
                                    await fileStorageManager.createFileReference(
                                        storeResult.fileId,
                                        'bubble_sticker',
                                        newStickerId
                                    );
                                    
                                    // æ·»åŠ åˆ°è´´çº¸åº“
                                    const newSticker = {
                                        id: newStickerId,
                                        fileId: storeResult.fileId,
                                        originalName: finalName,
                                        fileType: storeResult.type,
                                        size: storeResult.size
                                    };
                                    
                                    newStickerLibrary.push(newSticker);
                                    stickerLibrary.push(newSticker);
                                }
                                
                            } catch (error) {
                                console.warn(`å¯¼å…¥è´´çº¸å¤±è´¥:`, error);
                            }
                        }
                    }
                    
                    // 5. ä¿å­˜æ›´æ–°åçš„è´´çº¸åº“
                    await saveStickerLibraryToStorage();
                    await renderStickerLibrary();
                    
                    // 6. ç›´æ¥ä¿å­˜ä¸ºæ–°ä¸»é¢˜
                    if (config.bubbleStyles?.self || config.bubbleStyles?.kare) {
                        // ä¿å­˜ä¸ºæ–°ä¸»é¢˜ï¼Œè‡ªåŠ¨æ·»åŠ "ã€å¯¼å…¥ã€‘"åç¼€
                        let baseThemeName = config.themeName || 'å¯¼å…¥ä¸»é¢˜';
                        let importedThemeName = `${baseThemeName}ã€å¯¼å…¥ã€‘`;
                        let counter = 1;
                        let finalThemeName = importedThemeName;
                        
                        // ç¡®ä¿ä¸»é¢˜åç§°ä¸é‡å¤
                        while (availableThemes.includes(finalThemeName)) {
                            finalThemeName = `${importedThemeName}_${counter}`;
                            counter++;
                        }
                        
                        const themeData = {
                            type: `theme_${finalThemeName}`,
                            name: finalThemeName,
                            createdAt: new Date().toISOString(),
                            bubbleStyles: config.bubbleStyles,
                            stickerLibrary: newStickerLibrary
                        };
                        
                        // ä¿å­˜ä¸»é¢˜åˆ°æ•°æ®åº“
                        const transaction = db.transaction(['themeConfig'], 'readwrite');
                        const store = transaction.objectStore('themeConfig');
                        
                        await new Promise((resolve, reject) => {
                            const request = store.put(themeData);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        
                        // æ›´æ–°ä¸»é¢˜åˆ—è¡¨
                        availableThemes.push(finalThemeName);
                        updateThemeSelector();
                        
                        // è‡ªåŠ¨åˆ‡æ¢åˆ°æ–°å¯¼å…¥çš„ä¸»é¢˜
                        currentThemeName = finalThemeName;
                        await loadTheme(finalThemeName);
                        
                        showToast(`ä¸»é¢˜å·²å¯¼å…¥å¹¶ä¿å­˜ä¸º"${finalThemeName}"`, 'success');
                    }
                    else {
                        showToast(`æˆåŠŸå¯¼å…¥ ${newStickerLibrary.length} ä¸ªè´´çº¸ï¼`, 'success');
                    }
                    
                } catch (error) {
                    console.error('å¯¼å…¥ä¸»é¢˜å¤±è´¥:', error);
                    showToast('å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
                }
            }

            // å¤šä¸»é¢˜ç®¡ç†äº‹ä»¶ç›‘å¬å™¨
            controls.themeSelect.addEventListener('change', async (e) => {
                const selectedTheme = e.target.value;
                if (selectedTheme !== currentThemeName) {
                    await loadTheme(selectedTheme);
                }
            });

            controls.createNewThemeBtn.addEventListener('click', createNewTheme);

            controls.renameThemeBtn.addEventListener('click', async () => {
                await renameTheme(currentThemeName);
            });

            controls.deleteThemeBtn.addEventListener('click', async () => {
                await deleteTheme(currentThemeName);
            });

            // å¯¼å…¥å¯¼å‡ºäº‹ä»¶ç›‘å¬å™¨
            controls.exportThemeBtn.addEventListener('click', async () => {
                // æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
                if (hasUnsavedChanges()) {
                    const save = confirm('æ£€æµ‹åˆ°æœªä¿å­˜çš„æ›´æ”¹ã€‚æ˜¯å¦å…ˆä¿å­˜å½“å‰é…ç½®ï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"ä¿å­˜å¹¶å¯¼å‡º\nç‚¹å‡»"å–æ¶ˆ"æ”¾å¼ƒæ›´æ”¹å¹¶å¯¼å‡º');
                    if (save) {
                        // è§¦å‘ä¿å­˜æŒ‰é’®
                        controls.generateCodeBtn.click();
                        // ç­‰å¾…ä¿å­˜å®Œæˆ
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
                
                await exportBubbleTheme();
            });

            controls.importThemeFile.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file && file.name.endsWith('.zip')) {
                    await importBubbleTheme(file);
                } else if (file) {
                    showToast('è¯·é€‰æ‹©.zipæ ¼å¼çš„ä¸»é¢˜åŒ…æ–‡ä»¶', 'error');
                }
                // é‡ç½®æ–‡ä»¶è¾“å…¥
                e.target.value = '';
            });
            
            initializeApp();
        });
    </script>
</body>
</html>