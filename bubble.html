<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‹¬ç«‹çš„äº¤äº’å¼æ°”æ³¡æ ·å¼è®¾è®¡å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥FileStorageManagerç›¸å…³è„šæœ¬ -->
    <script src="utils/fileStorageManager.js"></script>
    <script src="utils/imageStorageAPI.js"></script>
    <script src="utils/imageDisplayHelper.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- ä¸­æ–‡å­—ä½“CDNå¯¼å…¥ -->
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/dymh/dist/DouyinSansBold/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/hwmct/dist/æ±‡æ–‡æ˜æœä½“/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/ToneOZ-Pinyin-Kai/dist/ToneOZ-PinyinW-Kai-Simplified/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/hcqyt/dist/ChillRoundFBold/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/ysbzt/dist/å³„å±±ç¢‘ç¯†ä½“/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/yfxy/dist/YuFanXinYu-Medium/result.css' />
    <style>
        body { font-family: 'Inter', sans-serif; }
        input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:6px;background:#e2e8f0;border-radius:3px;outline:none;opacity:.7;transition:opacity .2s}
        input[type="range"]:hover{opacity:1}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:#4f46e5;cursor:pointer;border-radius:50%;border:2px solid #fff;box-shadow:0 0 5px rgba(0,0,0,.2)}
        input[type="color"]{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:40px;height:40px;background-color:transparent;border:none;cursor:pointer}
        input[type="color"]::-webkit-color-swatch{border-radius:50%;border:2px solid #e2e8f0}
        
        .sticker-wrapper {
            position: absolute;
            width: 120px;
            height: auto;
            cursor: grab;
            user-select: none;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .sticker-wrapper.selected {
            border: 2px dashed #4f46e5;
        }
        .sticker-wrapper.dragging {
            cursor: grabbing;
            z-index: 10000 !important;
        }
        .sticker-wrapper.inactive {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }
        .sticker-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: fill; 
        }
        
        .resize-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background-color: #4f46e5;
            border: 2px solid white;
            border-radius: 4px;
            cursor: se-resize;
            z-index: 1001;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        #imageEditorCanvas.dropper-cursor { cursor: crosshair; }
        #stickerLibrary { position: absolute; bottom: 1rem; left: 1rem; z-index: 500; display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(255,255,255,0.8); padding: 0.5rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(5px); max-width: 280px; }
        .library-sticker { width: 60px; height: 60px; object-fit: contain; cursor: grab; transition: transform 0.2s; }
        .library-sticker:hover { transform: scale(1.1); }

        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            opacity: 1;
        }

        .bubble-type-btn {
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            outline: none;
        }
        .bubble-type-btn:hover {
            opacity: 0.8;
        }
        
        .sticker-container {
            position: relative;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">äº¤äº’å¼æ°”æ³¡æ ·å¼è®¾è®¡å™¨</h1>
            <p class="text-slate-500 mt-2">å•å‡»é€‰ä¸­è´´å›¾å¯è°ƒæ•´å›¾å±‚ï¼ŒåŒå‡»å¯åˆ é™¤ã€‚</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 bg-white rounded-2xl shadow-lg p-6 flex flex-col min-h-[400px] lg:min-h-[600px] overflow-hidden">
                <div class="flex-1 flex flex-col">
                    <!-- æ°”æ³¡ç±»å‹é€‰æ‹©æ§ä»¶ -->
                    <div class="mb-4 text-center">
                        <div class="inline-flex items-center bg-slate-200 rounded-full p-1">
                            <button id="bubbleTypeSelf" class="bubble-type-btn bg-white text-indigo-600 rounded-full px-4 py-2 text-sm font-semibold">æˆ‘çš„æ°”æ³¡</button>
                            <button id="bubbleTypeOthers" class="bubble-type-btn text-slate-600 rounded-full px-4 py-2 text-sm font-semibold">å¯¹æ–¹æ°”æ³¡</button>
                        </div>
                    </div>
                    
                    <!-- åŒæ°”æ³¡é¢„è§ˆåŒºåŸŸ -->
                    <div id="previewContainer" class="relative flex-1 flex flex-col justify-center space-y-4 p-4">
                        <!-- æˆ‘çš„æ°”æ³¡ -->
                        <div class="flex justify-end">
                            <div id="previewBubbleSelf" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(135, 206, 250); border-radius: 12px;">
                                <span id="bubbleTextContentSelf" style="position: relative; z-index: 10; color: rgb(255, 255, 255);">
                                    è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯
                                </span>
                                <div id="stickerLibrarySelf" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <!-- å¯¹æ–¹æ°”æ³¡ -->
                        <div class="flex justify-start">
                            <div id="previewBubbleOthers" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(255, 255, 255); border-radius: 12px;">
                                <span id="bubbleTextContentOthers" style="position: relative; z-index: 10; color: rgb(51, 51, 51);">
                                    è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯
                                </span>
                                <div id="stickerLibraryOthers" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <div id="stickerLibrary"></div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-2xl shadow-lg p-6 space-y-6 overflow-y-auto max-h-[calc(100vh-100px)]">
                <div>
                    <h3 class="font-semibold text-lg mb-3">è´´å›¾è£…é¥° (Stickers)</h3>
                    <button id="manageStickersBtn" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">ç®¡ç†è´´å›¾åº“</button>
                </div>
                <div id="layerControlPanel">
                    <h3 class="font-semibold text-lg mb-3">å›¾å±‚é¡ºåº</h3>
                    <div class="flex gap-2">
                        <button id="sendToBackBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>ç½®äºåº•å±‚</button>
                        <button id="bringToFrontBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>ç½®äºé¡¶å±‚</button>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">æ°”æ³¡åŸºç¡€æ ·å¼</h3>
                    <div class="space-y-4">
                        <div><label for="borderWidth" class="flex justify-between text-sm font-medium text-slate-700">è¾¹æ¡†å®½åº¦ <span id="borderWidthValue">1px</span></label><input type="range" id="borderWidth" min="0" max="50" value="1" class="mt-1"></div>
                        <div><label for="borderColor" class="flex justify-between items-center text-sm font-medium text-slate-700">è¾¹æ¡†é¢œè‰² <input type="color" id="borderColor" value="#4f46e5"></label></div>
                        <!-- ã€æ–°å¢ã€‘æ–‡æœ¬é¢œè‰²æ§åˆ¶å™¨ -->
                        <div><label for="textColor" class="flex justify-between items-center text-sm font-medium text-slate-700">æ–‡æœ¬é¢œè‰² <input type="color" id="textColor" value="#333333"></label></div>
                        <!-- ã€æ–°å¢ã€‘å­—ä½“é€‰æ‹©å™¨ -->
                        <div>
                            <label for="fontFamily" class="text-sm font-medium text-slate-700">å­—ä½“é€‰æ‹©</label>
                            <select id="fontFamily" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                <option value="Inter">é»˜è®¤å­—ä½“ (Inter)</option>
                                <option value="Source Han Serif CN VF">æ€æºå®‹ä½“</option>
                                <option value="LXGW WenKai">éœé¹œæ–‡æ¥·</option>
                                <option value="Douyin Sans">æŠ–éŸ³ç¾å¥½ä½“</option>
                                <option value="Huiwen-mincho">æ±‡æ–‡æ˜æœä½“</option>
                                <option value="ToneOZ-PinyinW-Kai-Simplified">æ‹¼éŸ³é¼æ¥·</option>
                                <option value="å¯’è‰å…¨åœ†ä½“ Bold">å¯’è‰å…¨åœ†ä½“</option>
                                <option value="å³„å±±ç¢‘ç¯†ä½“">å³„å±±ç¢‘ç¯†ä½“</option>
                                <option value="YuFanXinYu-Medium">ä½™ç¹æ–°è¯­</option>
                            </select>
                        </div>
                        <div><label for="borderRadius" class="flex justify-between text-sm font-medium text-slate-700">åœ†è§’åŠå¾„ <span id="borderRadiusValue">12px</span></label><input type="range" id="borderRadius" min="0" max="100" value="12" class="mt-1"></div>
                        <div class="flex items-center justify-between"><span class="text-sm font-medium text-slate-700">èƒŒæ™¯ç±»å‹</span><div class="flex items-center bg-slate-200 rounded-full p-1"><button id="bgTypeSolid" class="bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold">çº¯è‰²</button><button id="bgTypeGradient" class="bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold">æ¸å˜</button></div></div>
                        <div id="solidBgControls">
                             <div class="flex items-center justify-between"><label for="bgColor" class="text-sm font-medium text-slate-700">èƒŒæ™¯é¢œè‰²</label><input type="color" id="bgColor" value="#ffffff"></div>
                            <div><label for="bgOpacity" class="flex justify-between text-sm font-medium text-slate-700">é€æ˜åº¦ <span id="bgOpacityValue">100%</span></label><input type="range" id="bgOpacity" min="0" max="1" step="0.01" value="1" class="mt-1"></div>
                        </div>
                        <div id="gradientBgControls" class="hidden space-y-4">
                            <div class="flex items-center justify-between"><label for="gradientColor1" class="text-sm font-medium text-slate-700">é¢œè‰² 1</label><input type="color" id="gradientColor1" value="#a5b4fc"></div>
                            <div class="flex items-center justify-between"><label for="gradientColor2" class="text-sm font-medium text-slate-700">é¢œè‰² 2</label><input type="color" id="gradientColor2" value="#e0e7ff"></div>
                            <div><label for="gradientAngle" class="flex justify-between text-sm font-medium text-slate-700">æ¸å˜è§’åº¦ <span id="gradientAngleValue">145deg</span></label><input type="range" id="gradientAngle" min="0" max="360" value="145" class="mt-1"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">å†…å®¹ä¸ä»£ç </h3>
                    <div class="space-y-4">
                        <div><label for="bubbleText" class="text-sm font-medium text-slate-700">æ°”æ³¡æ–‡æœ¬</label><textarea id="bubbleText" rows="3" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">è¿™é‡Œæ˜¯ä½ çš„æ°”æ³¡é¢„è§ˆåŒºåŸŸã€‚ç‚¹å‡»"ç®¡ç†è´´å›¾åº“"å¼€å§‹åˆ›ä½œï¼</textarea></div>
                        <button id="generateCodeBtn" class="w-full bg-emerald-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors">åº”ç”¨æ­¤æ ·å¼åˆ°èŠå¤©</button>
                        <button id="resetToDefaultBtn" class="w-full bg-slate-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-slate-600 transition-colors">æ¢å¤é»˜è®¤æ°”æ³¡</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- è´´å›¾ç®¡ç†å™¨ Modal -->
    <div id="imageProcessorModal" class="fixed inset-0 bg-black bg-opacity-50 z-[1000] hidden flex items-center justify-center p-4">
        <div class="w-full h-full max-w-6xl max-h-[90vh] bg-white rounded-2xl shadow-2xl flex flex-col md:flex-row">
            <div class="w-full md:w-1/3 flex flex-col border-r border-slate-200">
                <div class="p-4 border-b border-slate-200">
                    <h3 class="font-bold text-xl">è´´å›¾åº“</h3>
                    <p class="text-sm text-slate-500">åœ¨è¿™é‡Œç®¡ç†å’Œç¼–è¾‘ä½ çš„è´´å›¾ã€‚</p>
                </div>
                <div id="stickerGallery" class="flex-1 p-4 overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-4">
                </div>
                <div class="p-4 border-t border-slate-200 space-y-2">
                    <label for="galleryStickerUpload" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">ä¸Šä¼ æ–°è´´å›¾</label>
                    <input type="file" id="galleryStickerUpload" accept="image/*" multiple class="hidden">
                    <p class="text-xs text-slate-500 mt-2 text-center">æç¤ºï¼šç§»é™¤èƒŒæ™¯åŠŸèƒ½ä¸æ”¯æŒGIFåŠ¨å›¾ã€‚è¯·å…ˆä½¿ç”¨å¤–éƒ¨å·¥å…·å¤„ç†GIFï¼Œå†ä¸Šä¼ ã€‚</p>
                    <button id="closeProcessorBtn" class="w-full bg-slate-600 text-white font-medium py-2 rounded-lg hover:bg-slate-700 mt-2">å®Œæˆå¹¶å…³é—­</button>
                </div>
            </div>
            <div class="w-full md:w-2/3 flex flex-col">
                <div id="imageEditor" class="flex-1 flex items-center justify-center bg-slate-100 p-4 relative">
                    <canvas id="imageEditorCanvas" class="max-w-full max-h-full shadow-lg"></canvas>
                    <div id="editorPlaceholder" class="text-slate-500">ä»å·¦ä¾§é€‰æ‹©ä¸€å¼ å›¾ç‰‡è¿›è¡Œç¼–è¾‘</div>
                </div>
                <div id="editorControls" class="p-4 border-t border-slate-200 bg-white space-y-4 hidden">
                    <button id="removeBgBtn" class="w-full bg-indigo-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-indigo-600">ğŸ’§ ç§»é™¤èƒŒæ™¯</button>
                    <div>
                        <label for="tolerance" class="flex justify-between text-sm font-medium text-slate-700">å®¹å·® <span id="toleranceValue">20</span></label>
                        <input type="range" id="tolerance" min="0" max="150" value="20" class="mt-1">
                    </div>
                    <div class="flex gap-2">
                        <button id="saveChangesBtn" class="w-full bg-emerald-500 text-white font-medium py-2 rounded-lg hover:bg-emerald-600">ä¿å­˜æ›´æ”¹</button>
                        <button id="resetStickerBtn" class="w-full bg-gray-500 text-white font-medium py-2 rounded-lg hover:bg-gray-600">é‡ç½®å›¾ç‰‡</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const previewContainer = document.getElementById('previewContainer');
            const previewBubbleSelf = document.getElementById('previewBubbleSelf');
            const previewBubbleOthers = document.getElementById('previewBubbleOthers');
            const bubbleTextContentSelf = document.getElementById('bubbleTextContentSelf');
            const bubbleTextContentOthers = document.getElementById('bubbleTextContentOthers');
            const stickerLibraryContainer = document.getElementById('stickerLibrary');
            const imageProcessorModal = document.getElementById('imageProcessorModal');
            const stickerGallery = document.getElementById('stickerGallery');
            const imageEditorCanvas = document.getElementById('imageEditorCanvas');
            const editorControls = document.getElementById('editorControls');
            const editorPlaceholder = document.getElementById('editorPlaceholder');
            const ctx = imageEditorCanvas.getContext('2d');
            
            const controls = {
                manageStickersBtn: document.getElementById('manageStickersBtn'),
                closeProcessorBtn: document.getElementById('closeProcessorBtn'),
                galleryStickerUpload: document.getElementById('galleryStickerUpload'),
                removeBgBtn: document.getElementById('removeBgBtn'),
                tolerance: document.getElementById('tolerance'),
                toleranceValue: document.getElementById('toleranceValue'),
                saveChangesBtn: document.getElementById('saveChangesBtn'),
                resetStickerBtn: document.getElementById('resetStickerBtn'),
                sendToBackBtn: document.getElementById('sendToBackBtn'),
                bringToFrontBtn: document.getElementById('bringToFrontBtn'),
                borderWidth: document.getElementById('borderWidth'),
                borderWidthValue: document.getElementById('borderWidthValue'),
                borderColor: document.getElementById('borderColor'),
                textColor: document.getElementById('textColor'),
                fontFamily: document.getElementById('fontFamily'),
                borderRadius: document.getElementById('borderRadius'),
                borderRadiusValue: document.getElementById('borderRadiusValue'),
                bgTypeSolid: document.getElementById('bgTypeSolid'),
                bgTypeGradient: document.getElementById('bgTypeGradient'),
                solidBgControls: document.getElementById('solidBgControls'),
                gradientBgControls: document.getElementById('gradientBgControls'),
                bgColor: document.getElementById('bgColor'),
                bgOpacity: document.getElementById('bgOpacity'),
                bgOpacityValue: document.getElementById('bgOpacityValue'),
                gradientColor1: document.getElementById('gradientColor1'),
                gradientColor2: document.getElementById('gradientColor2'),
                gradientAngle: document.getElementById('gradientAngle'),
                gradientAngleValue: document.getElementById('gradientAngleValue'),
                bubbleText: document.getElementById('bubbleText'),
                generateCodeBtn: document.getElementById('generateCodeBtn'),
                resetToDefaultBtn: document.getElementById('resetToDefaultBtn'),
                bubbleTypeSelf: document.getElementById('bubbleTypeSelf'),
                bubbleTypeOthers: document.getElementById('bubbleTypeOthers'),
            };

            const DB_NAME = 'WhaleLLTDB';
            const DB_VERSION = 11;
            let db = null;
            let fileStorageManager = null;
            let stickerLibrary = [];
            let currentEditingStickerId = null;
            let targetColor = null;
            let currentBgType = 'solid';
            let selectedStickerWrapper = null;
            let zIndexCounter = 11;
            let currentBubbleType = 'self'; // 'self' æˆ– 'others'

            function showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            }

            async function initStorageSystem() {
                try {
                    // ç›´æ¥ä½¿ç”¨ä¸»åº”ç”¨çš„ç°æœ‰æ•°æ®åº“è¿æ¥
                    if (window.parent && window.parent.db && window.parent.isIndexedDBReady) {
                        db = window.parent.db;
                        console.log('ä½¿ç”¨ä¸»åº”ç”¨çš„ç°æœ‰æ•°æ®åº“è¿æ¥ï¼Œç‰ˆæœ¬:', db.version);
                    } else {
                        // å¦‚æœæ²¡æœ‰çˆ¶çª—å£è¿æ¥ï¼Œåˆ›å»ºç‹¬ç«‹è¿æ¥
                        fileStorageManager = new FileStorageManager();
                        await fileStorageManager.init();
                        db = fileStorageManager.db;
                        console.log('åˆ›å»ºç‹¬ç«‹æ•°æ®åº“è¿æ¥æˆåŠŸ');
                    }
                    
                    // å¦‚æœè¿˜æ²¡æœ‰fileStorageManagerï¼Œåˆ›å»ºä¸€ä¸ªå¹¶ä½¿ç”¨ç°æœ‰è¿æ¥
                    if (!fileStorageManager) {
                        fileStorageManager = new FileStorageManager();
                        fileStorageManager.db = db;
                        console.log('FileStorageManageråˆå§‹åŒ–æˆåŠŸ');
                    }
                    
                    return true;
                } catch (error) {
                    console.error('å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
                    showToast('å­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨å†…å­˜å­˜å‚¨');
                    return false;
                }
            }

            async function saveStickerLibraryToStorage() {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡ä¿å­˜');
                        return;
                    }
                    
                    // ä½¿ç”¨ç°æœ‰æ•°æ®åº“çš„ themeConfig è¡¨ä¿å­˜è´´å›¾åº“
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // ä¿å­˜æ•´ä¸ªè´´å›¾åº“ä½œä¸ºä¸€ä¸ªä¸»é¢˜é…ç½®
                    const libraryData = {
                        type: 'bubbleStickers',
                        data: stickerLibrary,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(libraryData);
                    
                    transaction.oncomplete = () => {
                        console.log('è´´å›¾åº“ä¿å­˜åˆ° themeConfig æˆåŠŸ');
                    };
                    
                    transaction.onerror = () => {
                        console.error('è´´å›¾åº“ä¿å­˜å¤±è´¥:', transaction.error);
                        showToast('ä¿å­˜å¤±è´¥ï¼š' + transaction.error.message);
                    };
                } catch (e) {
                    console.error("æ— æ³•ä¿å­˜è´´å›¾åº“:", e);
                    showToast("é”™è¯¯ï¼šæ— æ³•ä¿å­˜è´´å›¾åº“ã€‚");
                }
            }

            async function loadStickerLibraryFromStorage() {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œä½¿ç”¨ç©ºè´´å›¾åº“');
                        stickerLibrary = [];
                        return;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get('bubbleStickers');
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result && result.data) {
                                stickerLibrary = result.data;
                                console.log('è´´å›¾åº“ä» themeConfig åŠ è½½æˆåŠŸï¼Œå…±', stickerLibrary.length, 'ä¸ªè´´å›¾');
                            } else {
                                stickerLibrary = [];
                                console.log('æœªæ‰¾åˆ°å·²ä¿å­˜çš„è´´å›¾åº“ï¼Œä½¿ç”¨ç©ºåº“');
                            }
                            resolve();
                        };
                        
                        request.onerror = () => {
                            console.error('åŠ è½½è´´å›¾åº“å¤±è´¥:', request.error);
                            stickerLibrary = [];
                            resolve(); // å³ä½¿å¤±è´¥ä¹Ÿè¦ç»§ç»­
                        };
                    });
                } catch (e) {
                    console.error("æ— æ³•åŠ è½½è´´å›¾åº“:", e);
                    stickerLibrary = [];
                }
            }

            function updateBubbleStyle() {
                const borderWidth = controls.borderWidth.value;
                const borderRadius = controls.borderRadius.value;
                
                // è·å–å½“å‰ç¼–è¾‘çš„æ°”æ³¡å…ƒç´ 
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                
                currentBubble.style.borderWidth = `${borderWidth}px`;
                currentBubble.style.borderColor = controls.borderColor.value;
                currentBubble.style.borderRadius = `${borderRadius}px`;
                
                // æ›´æ–°æ–‡æœ¬é¢œè‰²
                currentTextContent.style.color = controls.textColor.value;
                
                // æ›´æ–°å­—ä½“
                currentTextContent.style.fontFamily = controls.fontFamily.value;

                if (currentBgType === 'solid') {
                    const color = controls.bgColor.value;
                    const opacity = controls.bgOpacity.value;
                    const r = parseInt(color.slice(1, 3), 16), g = parseInt(color.slice(3, 5), 16), b = parseInt(color.slice(5, 7), 16);
                    currentBubble.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                } else {
                    const color1 = controls.gradientColor1.value, color2 = controls.gradientColor2.value, angle = controls.gradientAngle.value;
                    currentBubble.style.background = `linear-gradient(${angle}deg, ${color1}, ${color2})`;
                }
                controls.borderWidthValue.textContent = `${borderWidth}px`;
                controls.borderRadiusValue.textContent = `${borderRadius}px`;
                controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
            }

            // è·å–å½“å‰æ°”æ³¡ç±»å‹
            function getCurrentBubbleType() {
                return currentBubbleType || 'self';
            }

            // æ›´æ–°æ‰€æœ‰è´´çº¸çš„äº¤äº’çŠ¶æ€
            function updateStickersInteractionState() {
                // æ›´æ–°è‡ªå·±æ°”æ³¡ä¸­çš„è´´çº¸çŠ¶æ€
                previewBubbleSelf.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'self') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });

                // æ›´æ–°å¯¹æ–¹æ°”æ³¡ä¸­çš„è´´çº¸çŠ¶æ€
                previewBubbleOthers.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'others') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });
            }

            // åˆ‡æ¢æ°”æ³¡ç±»å‹
            async function switchBubbleType(type) {
                currentBubbleType = type;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                if (type === 'self') {
                    controls.bubbleTypeSelf.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.remove('text-slate-600');
                    controls.bubbleTypeOthers.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeOthers.classList.add('text-slate-600');
                } else {
                    controls.bubbleTypeOthers.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeOthers.classList.remove('text-slate-600');
                    controls.bubbleTypeSelf.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.add('text-slate-600');
                }
                
                // åŠ è½½å¯¹åº”ç±»å‹çš„æ ·å¼è®¾ç½®
                await loadBubbleTypeSettings(type);
                
                // æ›´æ–°è´´çº¸äº¤äº’çŠ¶æ€
                updateStickersInteractionState();
                
                showToast(`å·²åˆ‡æ¢åˆ°${type === 'self' ? 'æˆ‘çš„æ°”æ³¡' : 'å¯¹æ–¹æ°”æ³¡'}ç¼–è¾‘æ¨¡å¼`);
            }

            // åŠ è½½æŒ‡å®šæ°”æ³¡ç±»å‹çš„è®¾ç½®
            async function loadBubbleTypeSettings(type) {
                const targetBubble = type === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const targetTextContent = type === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                
                // é¦–å…ˆå°è¯•ä»ä¿å­˜çš„é…ç½®ä¸­åŠ è½½
                const styleKey = type === 'self' ? 'bubbleStyleSelf' : 'bubbleStyle';
                const savedConfig = await loadBubbleStyleConfig(styleKey);
                
                if (savedConfig) {
                    // å¦‚æœæœ‰ä¿å­˜çš„é…ç½®ï¼Œåº”ç”¨åˆ°æ§ä»¶
                    console.log(`åŠ è½½${type === 'self' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}æ°”æ³¡ä¿å­˜é…ç½®`);
                    
                    // åº”ç”¨åŸºç¡€æ ·å¼åˆ°æ§ä»¶
                    controls.borderWidth.value = savedConfig.borderWidth || 1;
                    controls.borderColor.value = savedConfig.borderColor || '#4f46e5';
                    controls.borderRadius.value = savedConfig.borderRadius || 12;
                    controls.textColor.value = savedConfig.textColor || '#333333';
                    controls.fontFamily.value = savedConfig.fontFamily || 'Inter';
                    
                    // åº”ç”¨èƒŒæ™¯æ ·å¼åˆ°æ§ä»¶
                    currentBgType = savedConfig.backgroundType || 'solid';
                    controls.bgColor.value = savedConfig.backgroundColor || '#ffffff';
                    controls.bgOpacity.value = savedConfig.backgroundOpacity || 1;
                    controls.gradientColor1.value = savedConfig.gradientColor1 || '#a5b4fc';
                    controls.gradientColor2.value = savedConfig.gradientColor2 || '#e0e7ff';
                    controls.gradientAngle.value = savedConfig.gradientAngle || 145;
                    
                    // åˆ‡æ¢èƒŒæ™¯ç±»å‹UI
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.click();
                    } else {
                        controls.bgTypeSolid.click();
                    }
                    
                    // æ–‡æœ¬å†…å®¹å§‹ç»ˆä½¿ç”¨é»˜è®¤å€¼ï¼Œä¸ä»é…ç½®ä¸­åŠ è½½
                    const defaultText = type === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                    
                } else {
                    // å¦‚æœæ²¡æœ‰ä¿å­˜çš„é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    console.log(`ä½¿ç”¨${type === 'self' ? 'æˆ‘çš„' : 'å¯¹æ–¹çš„'}æ°”æ³¡é»˜è®¤é…ç½®`);
                    
                    // è®¾ç½®é»˜è®¤å€¼
                    controls.borderWidth.value = 1;
                    controls.borderColor.value = '#4f46e5';
                    controls.borderRadius.value = 12;
                    controls.textColor.value = type === 'self' ? '#ffffff' : '#333333';
                    controls.fontFamily.value = 'Inter';
                    
                    currentBgType = 'solid';
                    controls.bgColor.value = type === 'self' ? '#87CEEB' : '#ffffff';
                    controls.bgOpacity.value = 1;
                    controls.gradientColor1.value = '#a5b4fc';
                    controls.gradientColor2.value = '#e0e7ff';
                    controls.gradientAngle.value = 145;
                    
                    controls.bgTypeSolid.click();
                    
                    // æ–‡æœ¬å†…å®¹å§‹ç»ˆä½¿ç”¨é»˜è®¤å€¼
                    const defaultText = type === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                }
                
                // æ›´æ–°æ ·å¼æ˜¾ç¤º
                updateBubbleStyle();
            }

            function openProcessor() { 
                imageProcessorModal.style.display = 'flex'; 
                populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error)); 
            }
            function closeProcessor() { 
                imageProcessorModal.style.display = 'none'; 
                renderStickerLibrary().catch(error => console.error('æ¸²æŸ“è´´å›¾åº“å¤±è´¥:', error)); 
            }

            async function handleStickerUpload(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                try {
                    showToast('æ­£åœ¨ä¸Šä¼ è´´å›¾...');
                    
                    for (const file of files) {
                        if (!file.type.startsWith('image/')) {
                            console.warn('è·³è¿‡éå›¾ç‰‡æ–‡ä»¶:', file.name);
                            continue;
                        }
                        
                        // ç”Ÿæˆå”¯ä¸€ID
                        const stickerId = 'sticker_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        
                        if (fileStorageManager) {
                            // ç›´æ¥ä½¿ç”¨FileStorageManagerå­˜å‚¨æ–‡ä»¶åˆ°IndexedDB
                            try {
                                const storeResult = await fileStorageManager.storeFile(file, {
                                    category: 'bubble_sticker',
                                    originalName: file.name
                                });
                                
                                // storeResult æ˜¯ä¸€ä¸ªå¯¹è±¡ {fileId, type, size}ï¼Œæˆ‘ä»¬éœ€è¦ fileId
                                const actualFileId = storeResult.fileId;
                                console.log('å­˜å‚¨ç»“æœ:', storeResult, 'å®é™…fileId:', actualFileId, 'ç±»å‹:', typeof actualFileId);
                                
                                // åˆ›å»ºæ–‡ä»¶å¼•ç”¨
                                await fileStorageManager.createFileReference(
                                    actualFileId,
                                    'bubble_sticker',
                                    stickerId,
                                    {
                                        originalName: file.name,
                                        fileType: storeResult.type,
                                        fileSize: storeResult.size
                                    }
                                );
                                
                                // åˆ›å»ºè´´å›¾è®°å½•ï¼ˆä¿å­˜fileIdå­—ç¬¦ä¸²ï¼Œç”¨äºè·å–fileSystemå¼•ç”¨ï¼‰
                                const newSticker = {
                                    id: stickerId,
                                    fileId: actualFileId,
                                    originalName: file.name,
                                    fileType: storeResult.type,
                                    fileSize: storeResult.size,
                                    createdAt: new Date().toISOString()
                                };
                                
                                stickerLibrary.push(newSticker);
                                console.log('è´´å›¾å­˜å‚¨æˆåŠŸ(IndexedDB+FileSystem):', newSticker);
                                
                            } catch (error) {
                                console.error('FileStorageManagerå­˜å‚¨å¤±è´¥ï¼Œå›é€€åˆ°base64:', error);
                                // å›é€€åˆ°base64å­˜å‚¨
                                await handleStickerUploadFallback(file, stickerId);
                            }
                        } else {
                            // å›é€€åˆ°base64å­˜å‚¨
                            await handleStickerUploadFallback(file, stickerId);
                        }
                    }
                    
                    await saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                    showToast(`æˆåŠŸä¸Šä¼  ${files.length} ä¸ªè´´å›¾`);
                    
                } catch (error) {
                    console.error('è´´å›¾ä¸Šä¼ å¤±è´¥:', error);
                    showToast('ä¸Šä¼ å¤±è´¥: ' + error.message);
                }
                
                event.target.value = '';
            }
            
            // å›é€€åˆ°base64å­˜å‚¨çš„å‡½æ•°
            async function handleStickerUploadFallback(file, stickerId) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const newSticker = {
                            id: stickerId,
                            baseSrc: e.target.result,
                            currentSrc: e.target.result,
                            originalName: file.name,
                            fileType: file.type,
                            fileSize: file.size,
                            createdAt: new Date().toISOString(),
                            isBase64: true // æ ‡è®°ä¸ºbase64å­˜å‚¨
                        };
                        stickerLibrary.push(newSticker);
                        console.log('è´´å›¾base64å­˜å‚¨æˆåŠŸ:', newSticker);
                        resolve();
                    };
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(file);
                });
            }
            
            async function populateStickerGallery() {
                stickerGallery.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const container = document.createElement('div');
                    container.className = 'relative group';
                    
                    const img = document.createElement('img');
                    img.className = 'w-full h-full object-contain bg-slate-200 rounded-md cursor-pointer hover:ring-2 ring-indigo-500';
                    img.dataset.id = sticker.id;
                    img.addEventListener('click', () => selectStickerForEditing(sticker.id));
                    
                    // è·å–å›¾ç‰‡URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            // ä½¿ç”¨FileStorageManagerè·å–fileSystemå¼•ç”¨URL
                            console.log('å°è¯•è·å–å›¾ç‰‡URLï¼ŒfileId:', sticker.fileId, 'ç±»å‹:', typeof sticker.fileId);
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            // å›é€€åˆ°base64
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('è´´å›¾æ— æœ‰æ•ˆçš„å›¾ç‰‡æº:', sticker);
                            imageUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4='; // å ä½ç¬¦SVG
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('è·å–è´´å›¾URLå¤±è´¥:', error);
                        img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4=';
                    }
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition-opacity z-10';
                    deleteBtn.addEventListener('click', async (e) => { 
                        e.stopPropagation(); 
                        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè´´çº¸å—ï¼Ÿæ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ–‡ä»¶ä¸”æ— æ³•æ¢å¤ã€‚')) {
                            await deleteSticker(sticker.id); 
                        }
                    });
                    
                    container.appendChild(img);
                    container.appendChild(deleteBtn);
                    stickerGallery.appendChild(container);
                }
            }
            
            async function deleteSticker(id) {
                // é¦–å…ˆè·å–è¦åˆ é™¤çš„è´´çº¸ä¿¡æ¯ï¼Œä»¥ä¾¿æ¸…ç†æ–‡ä»¶å­˜å‚¨
                const stickerToDelete = stickerLibrary.find(s => s.id === id);
                
                if (stickerToDelete && stickerToDelete.fileId && fileStorageManager) {
                    try {
                        console.log('æ¸…ç†è´´çº¸æ–‡ä»¶å­˜å‚¨ï¼ŒstickerId:', id, 'fileId:', stickerToDelete.fileId);
                        
                        // åˆ é™¤æ–‡ä»¶å¼•ç”¨
                        await fileStorageManager.deleteFileReference('bubble_sticker_' + id);
                        console.log('æ–‡ä»¶å¼•ç”¨åˆ é™¤æˆåŠŸ');
                        
                        // åˆ é™¤å®é™…æ–‡ä»¶ï¼ˆFileStorageManagerä¼šæ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–å¼•ç”¨ï¼‰
                        await fileStorageManager.deleteFile(stickerToDelete.fileId);
                        console.log('æ–‡ä»¶å­˜å‚¨åˆ é™¤æˆåŠŸ');
                        
                    } catch (error) {
                        console.error('æ¸…ç†æ–‡ä»¶å­˜å‚¨å¤±è´¥:', error);
                        // å³ä½¿æ–‡ä»¶å­˜å‚¨æ¸…ç†å¤±è´¥ï¼Œä¹Ÿç»§ç»­åˆ é™¤è´´çº¸è®°å½•
                    }
                }
                
                // ä»è´´çº¸åº“ä¸­ç§»é™¤
                stickerLibrary = stickerLibrary.filter(s => s.id != id);
                saveStickerLibraryToStorage();
                populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                
                if (currentEditingStickerId == id) {
                    currentEditingStickerId = null;
                    editorPlaceholder.classList.remove('hidden');
                    editorControls.classList.add('hidden');
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                }
            }

            async function renderStickerLibrary() {
                stickerLibraryContainer.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const img = document.createElement('img');
                    img.className = 'library-sticker';
                    img.dataset.id = sticker.id;
                    
                    // è·å–å›¾ç‰‡URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('è´´å›¾æ— æœ‰æ•ˆçš„å›¾ç‰‡æº:', sticker);
                            continue; // è·³è¿‡æ— æ•ˆè´´å›¾
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('è·å–è´´å›¾URLå¤±è´¥:', error);
                        continue; // è·³è¿‡å¤±è´¥çš„è´´å›¾
                    }
                    
                    makeLibraryStickerDraggable(img);
                    stickerLibraryContainer.appendChild(img);
                }
            }

            function selectStickerForEditing(id) {
                currentEditingStickerId = id;
                const sticker = stickerLibrary.find(s => s.id == id);
                if (!sticker) return;
                editorPlaceholder.classList.add('hidden');
                editorControls.classList.remove('hidden');
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.currentSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    ctx.drawImage(img, 0, 0);
                }
            }
            
            function processImage(colorToRemove, tolerance) {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (!sticker) return;
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.baseSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    const data = imageData.data;
                    const [tr, tg, tb] = colorToRemove;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const distance = Math.sqrt(Math.pow(r - tr, 2) + Math.pow(g - tg, 2) + Math.pow(b - tb, 2));
                        if (distance < tolerance) { data[i + 3] = 0; }
                    }
                    ctx.putImageData(imageData, 0, 0);
                };
            }

            // è·å–è´´å›¾URLçš„è¾…åŠ©å‡½æ•°
            async function getStickerImageURL(sticker) {
                try {
                    if (sticker.fileId && fileStorageManager) {
                        return await fileStorageManager.createFileURL(sticker.fileId);
                    } else if (sticker.currentSrc || sticker.baseSrc) {
                        return sticker.currentSrc || sticker.baseSrc;
                    } else {
                        console.warn('è´´å›¾æ— æœ‰æ•ˆçš„å›¾ç‰‡æº:', sticker);
                        return null;
                    }
                } catch (error) {
                    console.error('è·å–è´´å›¾URLå¤±è´¥:', error);
                    return sticker.currentSrc || sticker.baseSrc || null;
                }
            }

            function makeLibraryStickerDraggable(element) {
                element.addEventListener('mousedown', async (e) => {
                    e.preventDefault();
                    const stickerData = stickerLibrary.find(s => s.id == element.dataset.id);
                    if (!stickerData) return;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = zIndexCounter++; 
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // å¼‚æ­¥è·å–å›¾ç‰‡URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (!imageUrl) {
                        console.error('æ— æ³•è·å–è´´å›¾URLï¼Œè·³è¿‡åˆ›å»º');
                        return;
                    }
                    newSticker.src = imageUrl;
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    
                    // æ ¹æ®å½“å‰é€‰æ‹©çš„æ°”æ³¡ç±»å‹æ·»åŠ è´´å›¾
                    const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                    targetBubble.appendChild(wrapper);

                    const bubbleRect = targetBubble.getBoundingClientRect();
                    const initialWidth = 120;
                    wrapper.style.width = `${initialWidth}px`;
                    const tempImg = new Image();
                    tempImg.src = imageUrl;
                    tempImg.onload = () => {
                        const aspectRatio = tempImg.naturalHeight / tempImg.naturalWidth;
                        wrapper.style.height = `${initialWidth * aspectRatio}px`;
                        wrapper.style.left = `${(bubbleRect.width - wrapper.offsetWidth) / 2}px`;
                        wrapper.style.top = `${(bubbleRect.height - wrapper.offsetHeight) / 2}px`;
                    };
                    
                    makePlacedStickerInteractive(wrapper);
                    
                    // æ·»åŠ è´´çº¸åæ›´æ–°äº¤äº’çŠ¶æ€
                    updateStickersInteractionState();
                });
            }
            
            function makePlacedStickerInteractive(wrapper) {
                const resizeHandle = wrapper.querySelector('.resize-handle');
                let isDragging = false, isResizing = false;
                let offsetX, offsetY;

                function getCurrentBubbleContainer() {
                    // è·å–å½“å‰é€‰ä¸­çš„æ°”æ³¡å®¹å™¨
                    const currentType = getCurrentBubbleType();
                    return currentType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                }

                function isCurrentBubbleSticker() {
                    // æ£€æŸ¥è¿™ä¸ªè´´çº¸æ˜¯å¦å±äºå½“å‰é€‰ä¸­çš„æ°”æ³¡
                    const currentBubble = getCurrentBubbleContainer();
                    return currentBubble.contains(wrapper);
                }

                function onMoveDown(e) {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸äº¤äº’
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    isDragging = true;
                    wrapper.classList.add('dragging');
                    const event = e.touches ? e.touches[0] : e;
                    const rect = wrapper.getBoundingClientRect();
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    offsetX = event.clientX - rect.left;
                    offsetY = event.clientY - rect.top;
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onMoveUp);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onMoveUp);
                }
                function onMove(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    const event = e.touches ? e.touches[0] : e;
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    wrapper.style.left = `${event.clientX - bubbleRect.left - offsetX}px`;
                    wrapper.style.top = `${event.clientY - bubbleRect.top - offsetY}px`;
                }
                function onMoveUp() {
                    isDragging = false;
                    wrapper.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onMoveUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onMoveUp);
                }
                wrapper.addEventListener('mousedown', onMoveDown);
                wrapper.addEventListener('touchstart', onMoveDown, { passive: false });

                function onResizeDown(e) {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸äº¤äº’
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    isResizing = true;
                    const event = e.touches ? e.touches[0] : e;
                    const initialWidth = wrapper.offsetWidth;
                    const initialHeight = wrapper.offsetHeight;
                    const initialX = event.clientX;
                    const initialY = event.clientY;

                    function onResizeMove(e) {
                        if (!isResizing) return;
                        const event = e.touches ? e.touches[0] : e;
                        const deltaX = event.clientX - initialX;
                        const deltaY = event.clientY - initialY;
                        const newWidth = Math.max(20, initialWidth + deltaX);
                        const newHeight = Math.max(20, initialHeight + deltaY);
                        wrapper.style.width = `${newWidth}px`;
                        wrapper.style.height = `${newHeight}px`;
                    }

                    function onResizeUp() {
                        isResizing = false;
                        document.removeEventListener('mousemove', onResizeMove);
                        document.removeEventListener('mouseup', onResizeUp);
                        document.removeEventListener('touchmove', onResizeMove);
                        document.removeEventListener('touchend', onResizeUp);
                    }
                    
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeUp);
                    document.addEventListener('touchmove', onResizeMove, { passive: false });
                    document.addEventListener('touchend', onResizeUp);
                }
                resizeHandle.addEventListener('mousedown', onResizeDown);
                resizeHandle.addEventListener('touchstart', onResizeDown, { passive: false });

                wrapper.addEventListener('dblclick', () => {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸åˆ é™¤
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    wrapper.remove();
                    showToast('è´´å›¾å·²ç§»é™¤');
                });

                wrapper.addEventListener('click', (e) => {
                    // åªå…è®¸å½“å‰é€‰ä¸­æ°”æ³¡ä¸­çš„è´´çº¸è¢«é€‰æ‹©
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    selectSticker(wrapper);
                });
            }

            function selectSticker(wrapper) {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.remove('selected');
                }
                selectedStickerWrapper = wrapper;
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.add('selected');
                    controls.sendToBackBtn.disabled = false;
                    controls.bringToFrontBtn.disabled = false;
                } else {
                    controls.sendToBackBtn.disabled = true;
                    controls.bringToFrontBtn.disabled = true;
                }
            }
            previewContainer.addEventListener('click', (e) => {
                if (e.target === previewContainer || e.target === previewBubbleSelf || e.target === previewBubbleOthers) {
                    selectSticker(null);
                }
            });

            controls.sendToBackBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = 1;
                    showToast('å·²ç½®äºæ–‡å­—åº•å±‚');
                }
            });
            controls.bringToFrontBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = zIndexCounter++;
                    showToast('å·²ç½®äºæ–‡å­—é¡¶å±‚');
                }
            });


            controls.manageStickersBtn.addEventListener('click', openProcessor);
            controls.closeProcessorBtn.addEventListener('click', closeProcessor);
            controls.galleryStickerUpload.addEventListener('change', handleStickerUpload);
            controls.removeBgBtn.addEventListener('click', () => imageEditorCanvas.classList.add('dropper-cursor'));
            imageEditorCanvas.addEventListener('click', (e) => {
                if (!imageEditorCanvas.classList.contains('dropper-cursor')) return;
                const rect = imageEditorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                targetColor = [pixel[0], pixel[1], pixel[2]];
                imageEditorCanvas.classList.remove('dropper-cursor');
                processImage(targetColor, controls.tolerance.value);
            });
            controls.tolerance.addEventListener('input', () => {
                controls.toleranceValue.textContent = controls.tolerance.value;
                if (currentEditingStickerId && targetColor) {
                    processImage(targetColor, controls.tolerance.value);
                }
            });
            controls.saveChangesBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = imageEditorCanvas.toDataURL();
                    saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                }
            });
            controls.resetStickerBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = sticker.baseSrc;
                    saveStickerLibraryToStorage();
                    selectStickerForEditing(sticker.id);
                    populateStickerGallery().catch(error => console.error('å¡«å……è´´å›¾åº“å¤±è´¥:', error));
                }
            });

            // ã€ä¿®æ”¹ã€‘å°† textColor å’Œ fontFamily æ·»åŠ åˆ°äº‹ä»¶ç›‘å¬å¾ªç¯ä¸­
            ['borderWidth', 'borderColor', 'borderRadius', 'bgColor', 'bgOpacity', 'gradientColor1', 'gradientColor2', 'gradientAngle', 'textColor', 'fontFamily'].forEach(id => { if (controls[id]) { controls[id].addEventListener('input', updateBubbleStyle); } });
            controls.bubbleText.addEventListener('input', () => { 
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                currentTextContent.textContent = controls.bubbleText.value; 
            });
            controls.bgTypeSolid.addEventListener('click', () => { currentBgType = 'solid'; controls.solidBgControls.classList.remove('hidden'); controls.gradientBgControls.classList.add('hidden'); controls.bgTypeSolid.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.remove('text-slate-600'); controls.bgTypeGradient.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.add('text-slate-600'); updateBubbleStyle(); });
            controls.bgTypeGradient.addEventListener('click', () => { currentBgType = 'gradient'; controls.solidBgControls.classList.add('hidden'); controls.gradientBgControls.classList.remove('hidden'); controls.bgTypeGradient.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.remove('text-slate-600'); controls.bgTypeSolid.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.add('text-slate-600'); updateBubbleStyle(); });

            // æ°”æ³¡ç±»å‹åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
            controls.bubbleTypeSelf.addEventListener('click', () => switchBubbleType('self'));
            controls.bubbleTypeOthers.addEventListener('click', () => switchBubbleType('others'));
            
            // CSSæ ·å¼è§£æè¾…åŠ©å‡½æ•°
            function extractRgbColor(colorValue) {
                if (!colorValue) return '#ffffff';
                // å¦‚æœæ˜¯rgb/rgbaæ ¼å¼ï¼Œæå–RGBéƒ¨åˆ†
                const match = colorValue.match(/rgba?\(([^)]+)\)/);
                if (match) {
                    const values = match[1].split(',').map(v => parseInt(v.trim()));
                    return `#${values.slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')}`;
                }
                // å¦‚æœå·²ç»æ˜¯hexæ ¼å¼ï¼Œç›´æ¥è¿”å›
                if (colorValue.startsWith('#')) return colorValue;
                return '#ffffff';
            }

            function extractAlpha(colorValue) {
                if (!colorValue) return 1;
                const match = colorValue.match(/rgba?\([^,]+,[^,]+,[^,]+,?\s*([^)]*)\)/);
                if (match && match[1]) {
                    return parseFloat(match[1]) || 1;
                }
                return 1;
            }

            function extractGradientColors(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return ['#ffffff', '#ffffff'];
                }
                // åŒ¹é…gradientä¸­çš„é¢œè‰²
                const colorMatches = backgroundValue.match(/(#[0-9a-fA-F]{6}|rgb\([^)]+\)|rgba\([^)]+\))/g);
                if (colorMatches && colorMatches.length >= 2) {
                    return [extractRgbColor(colorMatches[0]), extractRgbColor(colorMatches[1])];
                }
                return ['#ffffff', '#ffffff'];
            }

            function extractGradientAngle(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return 0;
                }
                const angleMatch = backgroundValue.match(/(\d+)deg/);
                return angleMatch ? parseInt(angleMatch[1]) : 0;
            }

            // ä¸ºæŒ‡å®šæ°”æ³¡ç±»å‹ç”Ÿæˆå®Œæ•´é…ç½®
            function generateBubbleConfig(bubbleType) {
                const targetBubble = bubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const targetTextContent = bubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                const bubbleStyle = window.getComputedStyle(targetBubble);
                const textStyle = window.getComputedStyle(targetTextContent);
                
                // ç”Ÿæˆè´´çº¸HTML
                let htmlStickers = '';
                const bubbleWidth = targetBubble.offsetWidth;
                const bubbleHeight = targetBubble.offsetHeight;

                targetBubble.querySelectorAll('.sticker-wrapper').forEach((stickerWrapper, index) => {
                    const stickerImg = stickerWrapper.querySelector('.sticker-image');
                    const stickerId = stickerWrapper.dataset.id;
                    const stickerData = stickerLibrary.find(s => s.id == stickerId);
                    const stickerSrc = stickerImg.src;

                    const leftPx = parseFloat(stickerWrapper.style.left) || 0;
                    const topPx = parseFloat(stickerWrapper.style.top) || 0;
                    const stickerWidth = stickerWrapper.offsetWidth;
                    const stickerHeight = stickerWrapper.offsetHeight;

                    const leftPercent = (leftPx + stickerWidth / 2) / bubbleWidth;
                    const topPercent = (topPx + stickerHeight / 2) / bubbleHeight;
                    
                    let positionStyle = '';
                    if (leftPercent < 0.33 && topPercent < 0.33) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent < 0.33) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent < 0.33 && topPercent > 0.67) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent > 0.67) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else {
                        positionStyle = `left: ${((leftPx + stickerWidth / 2) / bubbleWidth * 100).toFixed(1)}%; top: ${((topPx + stickerHeight / 2) / bubbleHeight * 100).toFixed(1)}%; transform: translate(-50%, -50%);`;
                    }
                    
                    htmlStickers += `    <img src="${stickerSrc}" class="sticker-${index}" alt="sticker" style="position: absolute; ${positionStyle} width: ${stickerWidth.toFixed(0)}px; height: ${stickerHeight.toFixed(0)}px; z-index: ${stickerWrapper.style.zIndex || 1}; user-select: none; pointer-events: none;">\\n`;
                });

                const htmlTemplate = `<div class="chat-bubble" style="background: ${bubbleStyle.backgroundColor || bubbleStyle.background}; border: ${bubbleStyle.border}; border-radius: ${bubbleStyle.borderRadius}; padding: 12px; margin-bottom: 8px; max-width: 80%; word-wrap: break-word; position: relative; color: ${textStyle.color}; font-family: ${textStyle.fontFamily};">\\n    {{BUBBLE_TEXT}}\\n${htmlStickers}</div>`;

                return {
                    borderWidth: parseInt(bubbleStyle.borderWidth) || 0,
                    borderColor: bubbleStyle.borderColor || '#000000',
                    borderRadius: parseInt(bubbleStyle.borderRadius) || 0,
                    bgColor: extractRgbColor(bubbleStyle.backgroundColor || '#ffffff'),
                    bgOpacity: extractAlpha(bubbleStyle.backgroundColor || 'rgba(255,255,255,1)'),
                    bgType: bubbleStyle.background.includes('gradient') ? 'gradient' : 'solid',
                    gradientColor1: extractGradientColors(bubbleStyle.background)[0] || '#ffffff',
                    gradientColor2: extractGradientColors(bubbleStyle.background)[1] || '#ffffff',
                    gradientAngle: extractGradientAngle(bubbleStyle.background) || 0,
                    textColor: textStyle.color || '#000000',
                    fontFamily: textStyle.fontFamily || 'system-ui',
                    // bubbleText: ä¸ä¿å­˜æ–‡æœ¬å†…å®¹ï¼Œæ¯æ¬¡ä½¿ç”¨é»˜è®¤å€¼
                    stickers: Array.from(targetBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => ({
                        id: wrapper.dataset.id,
                        left: parseFloat(wrapper.style.left) || 0,
                        top: parseFloat(wrapper.style.top) || 0,
                        width: wrapper.offsetWidth,
                        height: wrapper.offsetHeight,
                        zIndex: wrapper.style.zIndex || 1
                    })),
                    html: htmlTemplate,
                    enabled: true
                };
            }

            controls.generateCodeBtn.addEventListener('click', async () => {
                // è°ƒè¯•ï¼šæ£€æŸ¥æ•°æ®åº“è¿æ¥çŠ¶æ€
                console.log('ä¿å­˜æŒ‰é’®ç‚¹å‡»ï¼Œæ•°æ®åº“çŠ¶æ€:', db ? 'å·²è¿æ¥' : 'æœªè¿æ¥');
                if (!db) {
                    console.error('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–...');
                    await initStorageSystem();
                    if (!db) {
                        alert('æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œæ— æ³•ä¿å­˜é…ç½®');
                        return;
                    }
                }
                
                // 1. ç”Ÿæˆå½“å‰é€‰æ‹©æ°”æ³¡ç±»å‹çš„HTMLå’ŒCSSä»£ç ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                const bubbleStyle = window.getComputedStyle(currentBubble);
                const textStyle = window.getComputedStyle(currentTextContent);
                
                // ã€æ›¿æ¢å¼€å§‹ã€‘
                let htmlStickers = '';
                const bubbleWidth = currentBubble.offsetWidth;
                const bubbleHeight = currentBubble.offsetHeight;

                currentBubble.querySelectorAll('.sticker-wrapper').forEach((stickerWrapper, index) => {
                    const stickerImg = stickerWrapper.querySelector('.sticker-image');
                    const stickerId = stickerWrapper.dataset.id;
                    const stickerData = stickerLibrary.find(s => s.id == stickerId);
                    const stickerSrc = stickerImg.src; // ä½¿ç”¨å½“å‰æ˜¾ç¤ºçš„URL

                    // --- å…¨æ–°çš„å®šä½å’Œå°ºå¯¸é€»è¾‘ ---
                    
                    // 1. è·å–è´´å›¾çš„å›ºå®šåƒç´ å°ºå¯¸å’Œä½ç½®
                    const leftPx = parseFloat(stickerWrapper.style.left) || 0;
                    const topPx = parseFloat(stickerWrapper.style.top) || 0;
                    const stickerWidth = stickerWrapper.offsetWidth;
                    const stickerHeight = stickerWrapper.offsetHeight;

                    // 2. åˆ¤æ–­è´´å›¾åœ¨æ°”æ³¡çš„å“ªä¸ªè±¡é™ï¼Œä»¥å†³å®šå…¶å®šä½é”šç‚¹
                    const leftPercent = (leftPx + stickerWidth / 2) / bubbleWidth;
                    const topPercent = (topPx + stickerHeight / 2) / bubbleHeight;
                    
                    let positionStyle = '';

                    // å¦‚æœè´´å›¾ä¸­å¿ƒç‚¹è¶…è¿‡äº†æ°”æ³¡é«˜åº¦çš„50%ï¼Œåˆ™ä½¿ç”¨ bottom å®šä½
                    if (topPercent > 0.5) {
                        const bottomPx = bubbleHeight - (topPx + stickerHeight);
                        positionStyle += `bottom: ${bottomPx.toFixed(0)}px; `;
                    } else {
                        positionStyle += `top: ${topPx.toFixed(0)}px; `;
                    }

                    // å¦‚æœè´´å›¾ä¸­å¿ƒç‚¹è¶…è¿‡äº†æ°”æ³¡å®½åº¦çš„50%ï¼Œåˆ™ä½¿ç”¨ right å®šä½
                    if (leftPercent > 0.5) {
                        const rightPx = bubbleWidth - (leftPx + stickerWidth);
                        positionStyle += `right: ${rightPx.toFixed(0)}px; `;
                    } else {
                        positionStyle += `left: ${leftPx.toFixed(0)}px; `;
                    }
                    
                    // 3. ç”Ÿæˆä»£ç ï¼šä½ç½®ç”¨è®¡ç®—å‡ºçš„é”šç‚¹å®šä½ï¼Œå°ºå¯¸ç”¨å›ºå®šçš„åƒç´ å€¼
                    htmlStickers += `    <img src="${stickerSrc}" class="sticker-${index}" alt="sticker" style="position: absolute; ${positionStyle} width: ${stickerWidth.toFixed(0)}px; height: ${stickerHeight.toFixed(0)}px; z-index: ${stickerWrapper.style.zIndex || 1}; user-select: none; pointer-events: none;">\\n`;
                });
                // ã€æ›¿æ¢ç»“æŸã€‘

                const htmlTemplate = `<div class="custom-bubble-container" style="position: relative; padding: ${bubbleStyle.padding}; border: ${bubbleStyle.border}; border-radius: ${bubbleStyle.borderRadius}; background: ${bubbleStyle.background};">\\n    <span class="bubble-text" style="position: relative; z-index: 10; color: ${textStyle.color}; font-family: &quot;${textStyle.fontFamily.replace(/"/g, '')}&quot;;">{{BUBBLE_TEXT}}</span>\\n${htmlStickers}</div>`;
                
                // æˆ‘ä»¬ä¸å†éœ€è¦ç”ŸæˆCSSï¼Œå› ä¸ºæ ·å¼å·²ç»å†…è”åˆ°HTMLä¸­äº†
                const cssCode = `/* CSS å·²å†…è”ï¼Œæ­¤éƒ¨åˆ†ä¸ºç©º */`;

                // 2. å°†æŒ‰é’®æ–‡æœ¬æ”¹ä¸º "åº”ç”¨æ­¤æ ·å¼"
                controls.generateCodeBtn.textContent = 'åº”ç”¨æ­¤æ ·å¼';

                // 3. æ”¶é›†å®Œæ•´çš„æ ·å¼é…ç½®
                const completeStyleConfig = {
                    // åŸºç¡€æ ·å¼
                    borderWidth: controls.borderWidth.value,
                    borderColor: controls.borderColor.value,
                    borderRadius: controls.borderRadius.value,
                    textColor: controls.textColor.value,
                    fontFamily: controls.fontFamily.value,
                    
                    // èƒŒæ™¯æ ·å¼
                    backgroundType: currentBgType,
                    backgroundColor: controls.bgColor.value,
                    backgroundOpacity: controls.bgOpacity.value,
                    gradientColor1: controls.gradientColor1.value,
                    gradientColor2: controls.gradientColor2.value,
                    gradientAngle: controls.gradientAngle.value,
                                        
                    // è´´å›¾é…ç½®
                    stickers: Array.from(currentBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => ({
                        id: wrapper.dataset.id,
                        left: parseFloat(wrapper.style.left) || 0,
                        top: parseFloat(wrapper.style.top) || 0,
                        width: wrapper.offsetWidth,
                        height: wrapper.offsetHeight,
                        zIndex: wrapper.style.zIndex || 1
                    })),
                    
                    // ç”Ÿæˆçš„HTMLæ¨¡æ¿
                    html: htmlTemplate,
                    css: cssCode,
                    
                    // å…ƒæ•°æ®
                    createdAt: new Date().toISOString(),
                    version: '1.0'
                };

                // 4. ç¡®ä¿å¯ç”¨æ ‡å¿—ä¸º trueï¼ˆæ¯æ¬¡ä¿å­˜éƒ½è‡ªåŠ¨å¯ç”¨ï¼‰
                completeStyleConfig.enabled = true;
                
                // 5. ç”Ÿæˆå¹¶ä¿å­˜åŒæ–¹æ°”æ³¡çš„å®Œæ•´é…ç½®
                const selfConfig = generateBubbleConfig('self');
                const othersConfig = generateBubbleConfig('others');
                
                // åŒæ—¶ä¿å­˜åŒæ–¹çš„é…ç½®
                await saveBubbleStyleConfig(selfConfig, 'bubbleStyleSelf');
                await saveBubbleStyleConfig(othersConfig, 'bubbleStyle');

                // 6. ä½¿ç”¨ postMessage å‘é€åŒæ–¹é…ç½®ç»™çˆ¶çª—å£
                window.parent.postMessage({
                    type: 'apply-bubble-style',
                    payload: {
                        self: selfConfig,
                        others: othersConfig,
                        current: completeStyleConfig // ä¿ç•™å½“å‰é€‰ä¸­çš„é…ç½®ç”¨äºæ˜¾ç¤º
                    },
                    bubbleType: currentBubbleType
                }, '*');

                // 7. ç»™ç”¨æˆ·ä¸€ä¸ªåé¦ˆ
                showToast('å·²ä¿å­˜åŒæ–¹æ°”æ³¡æ ·å¼å¹¶åº”ç”¨åˆ°èŠå¤©ç•Œé¢ï¼');
                const originalText = controls.generateCodeBtn.textContent;
                controls.generateCodeBtn.textContent = 'âœ… å·²åº”ç”¨!';
                setTimeout(() => {
                    controls.generateCodeBtn.textContent = originalText;
                }, 2000);
            });

            // æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼æŒ‰é’®äº‹ä»¶
            controls.resetToDefaultBtn.addEventListener('click', async () => {
                // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰è‡ªå®šä¹‰è®¾ç½®ã€‚')) {
                    controls.resetToDefaultBtn.textContent = 'æ­£åœ¨æ¢å¤...';
                    controls.resetToDefaultBtn.disabled = true;
                    
                    await resetToDefaultBubbleStyle();
                    
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    setTimeout(() => {
                        controls.resetToDefaultBtn.textContent = 'æ¢å¤é»˜è®¤æ°”æ³¡';
                        controls.resetToDefaultBtn.disabled = false;
                    }, 1500);
                }
            });

            // ä¿å­˜å®Œæ•´çš„æ°”æ³¡æ ·å¼é…ç½®
            async function saveBubbleStyleConfig(styleConfig, styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡ä¿å­˜é…ç½®');
                        return;
                    }
                    
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // å°† enabled å±æ€§æ·»åŠ åˆ° styleConfig æœ¬èº«
                    const configData = {
                        type: styleKey,
                        ...styleConfig, // å±•å¼€æ‰€æœ‰æ ·å¼é…ç½®åˆ°é¡¶å±‚
                        enabled: true,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(configData);
                    
                    transaction.oncomplete = () => {
                        console.log(`${styleKey}é…ç½®ä¿å­˜æˆåŠŸ`);
                    };
                    
                    transaction.onerror = () => {
                        console.error(`${styleKey}é…ç½®ä¿å­˜å¤±è´¥:`, transaction.error);
                    };
                } catch (e) {
                    console.error(`æ— æ³•ä¿å­˜${styleKey}é…ç½®:`, e);
                }
            }

            // æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼
            async function resetToDefaultBubbleStyle() {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡ç¦ç”¨é…ç½®');
                        return;
                    }
                    
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // åˆ é™¤ä¸¤ç§æ°”æ³¡æ ·å¼é…ç½®ï¼Œä½†ä¿ç•™è´´çº¸åº“
                    store.delete('bubbleStyle');      // åˆ é™¤å¯¹æ–¹æ°”æ³¡é…ç½®
                    store.delete('bubbleStyleSelf');  // åˆ é™¤è‡ªå·±æ°”æ³¡é…ç½®
                    
                    transaction.oncomplete = () => {
                        console.log('æ‰€æœ‰è‡ªå®šä¹‰æ°”æ³¡æ ·å¼é…ç½®å·²åˆ é™¤');
                        
                        // æ¸…ç†ä¸¤ä¸ªæ°”æ³¡å®¹å™¨ä¸Šçš„è´´çº¸
                        previewBubbleSelf.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                        previewBubbleOthers.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                        
                        // é‡ç½®æ‰€æœ‰æ§ä»¶åˆ°é»˜è®¤å€¼
                        resetControlsToDefault();
                    };
                    
                    transaction.onerror = () => {
                        console.error('åˆ é™¤æ°”æ³¡æ ·å¼é…ç½®å¤±è´¥:', transaction.error);
                    };
                    
                    // ä½¿ç”¨ postMessage é€šçŸ¥çˆ¶çª—å£æ¢å¤é»˜è®¤æ ·å¼
                    window.parent.postMessage({
                        type: 'reset-bubble-style'
                    }, '*');
                    
                    showToast('å·²æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼ï¼è´´çº¸åº“ä¿æŒä¸å˜ã€‚');
                } catch (e) {
                    console.error("æ— æ³•æ¢å¤é»˜è®¤æ°”æ³¡æ ·å¼:", e);
                    showToast("æ¢å¤é»˜è®¤æ ·å¼å¤±è´¥");
                }
            }

            // é‡ç½®æ‰€æœ‰æ§ä»¶åˆ°é»˜è®¤å€¼
            function resetControlsToDefault() {
                // é‡ç½®åŸºç¡€æ ·å¼æ§ä»¶
                controls.bgColor.value = '#3b82f6';
                controls.textColor.value = '#ffffff';
                controls.borderRadius.value = 18;
                controls.borderWidth.value = 0;
                controls.borderColor.value = '#e2e8f0';
                controls.bgOpacity.value = 1;
                controls.borderOpacity.value = 1;
                
                // é‡ç½®æ¸å˜ç›¸å…³
                controls.bgType.value = 'solid';
                controls.gradientType.value = 'linear';
                controls.gradientColor1.value = '#3b82f6';
                controls.gradientColor2.value = '#1d4ed8';
                controls.gradientAngle.value = 45;
                
                // é‡ç½®æ–‡æœ¬å†…å®¹ä¸ºå½“å‰æ°”æ³¡ç±»å‹çš„é»˜è®¤å€¼
                const defaultText = currentBubbleType === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                controls.bubbleText.value = defaultText;
                
                // åŒæ—¶æ›´æ–°é¢„è§ˆæ˜¾ç¤º
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                currentTextContent.textContent = defaultText;
                
                // æ›´æ–°æ˜¾ç¤ºå€¼
                updateValueDisplays();
                
                // é‡æ–°åº”ç”¨æ ·å¼åˆ°é¢„è§ˆæ°”æ³¡
                updateBubblePreview();
                
                console.log('æ‰€æœ‰æ§ä»¶å·²é‡ç½®åˆ°é»˜è®¤å€¼');
            }

            // åŠ è½½å®Œæ•´çš„æ°”æ³¡æ ·å¼é…ç½®
            async function loadBubbleStyleConfig(styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('æ•°æ®åº“è¿æ¥ä¸å¯ç”¨ï¼Œè·³è¿‡åŠ è½½é…ç½®');
                        return null;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get(styleKey);
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result) {
                                console.log(`${styleKey}é…ç½®åŠ è½½æˆåŠŸ`);
                                // ç§»é™¤ type å’Œç³»ç»Ÿå­—æ®µï¼Œè¿”å›æ ·å¼é…ç½®
                                const { type, lastModified, ...styleConfig } = result;
                                resolve(styleConfig);
                            } else {
                                console.log(`æœªæ‰¾åˆ°å·²ä¿å­˜çš„${styleKey}é…ç½®`);
                                resolve(null);
                            }
                        };
                        
                        request.onerror = () => {
                            console.error(`åŠ è½½${styleKey}é…ç½®å¤±è´¥:`, request.error);
                            resolve(null);
                        };
                    });
                } catch (e) {
                    console.error(`æ— æ³•åŠ è½½${styleKey}é…ç½®:`, e);
                    return null;
                }
            }

            // åº”ç”¨ä¿å­˜çš„é…ç½®åˆ°ç•Œé¢
            async function applyBubbleStyleConfig(config) {
                if (!config) return;
                
                try {
                    // åº”ç”¨åŸºç¡€æ ·å¼
                    controls.borderWidth.value = config.borderWidth || 1;
                    controls.borderColor.value = config.borderColor || '#4f46e5';
                    controls.borderRadius.value = config.borderRadius || 12;
                    controls.textColor.value = config.textColor || '#333333';
                    controls.fontFamily.value = config.fontFamily || 'Inter';
                    
                    // åº”ç”¨èƒŒæ™¯æ ·å¼
                    currentBgType = config.backgroundType || 'solid';
                    controls.bgColor.value = config.backgroundColor || '#ffffff';
                    controls.bgOpacity.value = config.backgroundOpacity || 1;
                    controls.gradientColor1.value = config.gradientColor1 || '#a5b4fc';
                    controls.gradientColor2.value = config.gradientColor2 || '#e0e7ff';
                    controls.gradientAngle.value = config.gradientAngle || 145;
                    
                    // åˆ‡æ¢èƒŒæ™¯ç±»å‹
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.click();
                    } else {
                        controls.bgTypeSolid.click();
                    }
                    
                    // æ–‡æœ¬å†…å®¹å§‹ç»ˆä½¿ç”¨é»˜è®¤å€¼ï¼Œä¸ä»é…ç½®ä¸­åº”ç”¨
                    const defaultText = currentBubbleType === 'self' ? 'è¿™æ˜¯æˆ‘å‘çš„æ¶ˆæ¯' : 'è¿™æ˜¯å¯¹æ–¹å‘çš„æ¶ˆæ¯';
                    controls.bubbleText.value = defaultText;
                    const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                    currentTextContent.textContent = defaultText;
                    
                    // æ¢å¤è´´å›¾ï¼ˆä¸åœ¨è¿™é‡Œå¤„ç†ï¼Œåœ¨åˆå§‹åŒ–å‡½æ•°ä¸­å¤„ç†ï¼‰
                    // if (config.stickers && config.stickers.length > 0) {
                    //     await restoreStickers(config.stickers, currentBubbleType);
                    // }
                    
                    // æ›´æ–°æ ·å¼
                    updateBubbleStyle();
                    
                    console.log('æ°”æ³¡æ ·å¼é…ç½®å·²åº”ç”¨åˆ°ç•Œé¢');
                } catch (error) {
                    console.error('åº”ç”¨æ°”æ³¡æ ·å¼é…ç½®å¤±è´¥:', error);
                }
            }

            // æ¢å¤è´´å›¾
            async function restoreStickers(stickerConfigs, targetBubbleType = 'others') {
                // æ¸…é™¤å¯¹åº”æ°”æ³¡çš„ç°æœ‰è´´å›¾
                const targetBubble = targetBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                targetBubble.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                
                for (const stickerConfig of stickerConfigs) {
                    const stickerData = stickerLibrary.find(s => s.id === stickerConfig.id);
                    if (!stickerData) {
                        console.warn('æ‰¾ä¸åˆ°è´´å›¾æ•°æ®:', stickerConfig.id);
                        continue;
                    }
                    
                    // åˆ›å»ºè´´å›¾å…ƒç´ 
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = stickerConfig.zIndex;
                    wrapper.style.left = stickerConfig.left + 'px';
                    wrapper.style.top = stickerConfig.top + 'px';
                    wrapper.style.width = stickerConfig.width + 'px';
                    wrapper.style.height = stickerConfig.height + 'px';
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // è·å–å›¾ç‰‡URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (imageUrl) {
                        newSticker.src = imageUrl;
                    }
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    targetBubble.appendChild(wrapper);
                    
                    makePlacedStickerInteractive(wrapper);
                }
                
                // æ¢å¤è´´çº¸åæ›´æ–°äº¤äº’çŠ¶æ€
                updateStickersInteractionState();
            }

            // å¼‚æ­¥åˆå§‹åŒ–
            async function initializeApp() {
                await initStorageSystem();
                await loadStickerLibraryFromStorage();
                await renderStickerLibrary();
                
                // åŠ è½½å¹¶åº”ç”¨ä¿å­˜çš„é…ç½®ï¼ˆä¸¤ç§æ°”æ³¡æ ·å¼ï¼‰
                const savedSelfConfig = await loadBubbleStyleConfig('bubbleStyleSelf');
                const savedOthersConfig = await loadBubbleStyleConfig('bubbleStyle');
                
                if (savedSelfConfig) {
                    // åˆ‡æ¢åˆ°è‡ªå·±æ¨¡å¼å¹¶åº”ç”¨é…ç½®
                    currentBubbleType = 'self';
                    await applyBubbleStyleConfig(savedSelfConfig);
                    
                    // æ¢å¤è‡ªå·±çš„è´´å›¾
                    if (savedSelfConfig.stickers && savedSelfConfig.stickers.length > 0) {
                        await restoreStickers(savedSelfConfig.stickers, 'self');
                    }
                }
                
                if (savedOthersConfig) {
                    // åˆ‡æ¢åˆ°åˆ«äººæ¨¡å¼å¹¶åº”ç”¨é…ç½®
                    currentBubbleType = 'others';
                    await applyBubbleStyleConfig(savedOthersConfig);
                    
                    // æ¢å¤åˆ«äººçš„è´´å›¾
                    if (savedOthersConfig.stickers && savedOthersConfig.stickers.length > 0) {
                        await restoreStickers(savedOthersConfig.stickers, 'others');
                    }
                }
                
                // é»˜è®¤åˆ‡æ¢åˆ°è‡ªå·±çš„æ°”æ³¡ç¼–è¾‘æ¨¡å¼
                switchBubbleType('self');
                
                // å¦‚æœæ²¡æœ‰ä¿å­˜çš„é…ç½®ï¼Œåº”ç”¨é»˜è®¤æ ·å¼
                if (!savedSelfConfig && !savedOthersConfig) {
                    updateBubbleStyle();
                }
            }
            
            initializeApp();
        });
    </script>
</body>
</html>